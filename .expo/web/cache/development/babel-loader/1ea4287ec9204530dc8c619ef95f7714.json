{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport pathToRegexp, { compile } from 'path-to-regexp';\nimport * as NavigationActions from \"../NavigationActions\";\nimport invariant from \"../utils/invariant\";\n\nvar queryString = require('query-string');\n\nexport var getParamsFromPath = function getParamsFromPath(inputParams, pathMatch, pathMatchKeys) {\n  var params = pathMatch.slice(1).reduce(function (paramsOut, matchResult, i) {\n    var key = pathMatchKeys[i];\n\n    if (!key || key.asterisk) {\n      return paramsOut;\n    }\n\n    var paramName = key.name;\n    var decodedMatchResult;\n\n    if (matchResult) {\n      try {\n        decodedMatchResult = decodeURIComponent(matchResult);\n      } catch (e) {}\n    }\n\n    paramsOut[paramName] = decodedMatchResult || matchResult;\n    return paramsOut;\n  }, _objectSpread({}, inputParams));\n  return params;\n};\n\nvar getRestOfPath = function getRestOfPath(pathMatch, pathMatchKeys) {\n  var rest = pathMatch[pathMatchKeys.findIndex(function (k) {\n    return k.asterisk;\n  }) + 1];\n  return rest;\n};\n\nvar determineDelimiter = function determineDelimiter(uri, uriPrefix) {\n  if (Array.isArray(uriPrefix)) {\n    if (uriPrefix.length === 1) return uriPrefix[0];\n\n    for (var _iterator = uriPrefix, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _prefix = _ref;\n      if (uri.startsWith(_prefix)) return _prefix;\n    }\n\n    return null;\n  }\n\n  return uriPrefix;\n};\n\nexport var urlToPathAndParams = function urlToPathAndParams(url, uriPrefix) {\n  var searchMatch = url.match(/^(.*)\\?(.*)$/);\n\n  var _ref2 = searchMatch || [null, url, {}],\n      _ref3 = _slicedToArray(_ref2, 3),\n      urlWithoutQuery = _ref3[1],\n      query = _ref3[2];\n\n  var params = queryString.parse(query);\n  var delimiter = determineDelimiter(urlWithoutQuery, uriPrefix) || '://';\n  var path = urlWithoutQuery.split(delimiter)[1];\n\n  if (path === undefined) {\n    path = urlWithoutQuery;\n  }\n\n  if (path === '/') {\n    path = '';\n  }\n\n  if (path[path.length - 1] === '/') {\n    path = path.slice(0, -1);\n  }\n\n  return {\n    path: path,\n    params: params\n  };\n};\nexport var createPathParser = function createPathParser(childRouters, routeConfigs, _ref4) {\n  var _ref4$paths = _ref4.paths,\n      pathConfigs = _ref4$paths === void 0 ? {} : _ref4$paths,\n      disableRouteNamePaths = _ref4.disableRouteNamePaths;\n  var pathsByRouteNames = {};\n  var paths = [];\n  Object.keys(childRouters).forEach(function (routeName) {\n    var pathPattern;\n\n    if (pathConfigs[routeName] !== undefined) {\n      pathPattern = pathConfigs[routeName];\n    } else {\n      pathPattern = routeConfigs[routeName].path;\n    }\n\n    if (pathPattern === undefined) {\n      pathPattern = disableRouteNamePaths ? null : routeName;\n    }\n\n    invariant(pathPattern === null || typeof pathPattern === 'string', \"Route path for \".concat(routeName, \" must be specified as a string, or null.\"));\n    var isPathMatchable = pathPattern !== null;\n    var exactReKeys = [];\n    var exactRe = isPathMatchable ? pathToRegexp(pathPattern, exactReKeys) : null;\n    var extendedPathReKeys = [];\n    var isWildcard = pathPattern === '' || !isPathMatchable;\n    var extendedPathRe = pathToRegexp(isWildcard ? '*' : \"\".concat(pathPattern, \"/*\"), extendedPathReKeys);\n    pathsByRouteNames[routeName] = {\n      exactRe: exactRe,\n      exactReKeys: exactReKeys,\n      extendedPathRe: extendedPathRe,\n      extendedPathReKeys: extendedPathReKeys,\n      isWildcard: isWildcard,\n      toPath: pathPattern === null ? function () {\n        return '';\n      } : compile(pathPattern)\n    };\n  });\n  paths = Object.entries(pathsByRouteNames);\n\n  var getActionForPathAndParams = function getActionForPathAndParams() {\n    var pathToResolve = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var inputParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var _iterator2 = paths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref7;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref7 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref7 = _i2.value;\n      }\n\n      var _ref11 = _ref7;\n\n      var _ref6 = _slicedToArray(_ref11, 2);\n\n      var _routeName2 = _ref6[0];\n      var _path2 = _ref6[1];\n      var _exactRe = _path2.exactRe,\n          _exactReKeys = _path2.exactReKeys,\n          _extendedPathRe2 = _path2.extendedPathRe,\n          _extendedPathReKeys2 = _path2.extendedPathReKeys;\n      var _childRouter2 = childRouters[_routeName2];\n\n      var _exactMatch = _exactRe && _exactRe.exec(pathToResolve);\n\n      if (_exactMatch && _exactMatch.length) {\n        var _extendedMatch = _extendedPathRe2 && _extendedPathRe2.exec(pathToResolve);\n\n        var childAction = null;\n\n        if (_extendedMatch && _childRouter2) {\n          var restOfPath = getRestOfPath(_extendedMatch, _extendedPathReKeys2);\n          childAction = _childRouter2.getActionForPathAndParams(restOfPath, inputParams);\n        }\n\n        return NavigationActions.navigate({\n          routeName: _routeName2,\n          params: getParamsFromPath(inputParams, _exactMatch, _exactReKeys),\n          action: childAction\n        });\n      }\n    }\n\n    for (var _iterator3 = paths, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref10;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref10 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref10 = _i3.value;\n      }\n\n      var _ref12 = _ref10;\n\n      var _ref9 = _slicedToArray(_ref12, 2);\n\n      var _routeName3 = _ref9[0];\n      var _path3 = _ref9[1];\n      var _extendedPathRe3 = _path3.extendedPathRe,\n          _extendedPathReKeys3 = _path3.extendedPathReKeys;\n      var _childRouter3 = childRouters[_routeName3];\n\n      var _extendedMatch2 = _extendedPathRe3 && _extendedPathRe3.exec(pathToResolve);\n\n      if (_extendedMatch2 && _extendedMatch2.length) {\n        var _restOfPath = getRestOfPath(_extendedMatch2, _extendedPathReKeys3);\n\n        var _childAction = null;\n\n        if (_childRouter3) {\n          _childAction = _childRouter3.getActionForPathAndParams(_restOfPath, inputParams);\n        }\n\n        if (!_childAction) {\n          continue;\n        }\n\n        return NavigationActions.navigate({\n          routeName: _routeName3,\n          params: getParamsFromPath(inputParams, _extendedMatch2, _extendedPathReKeys3),\n          action: _childAction\n        });\n      }\n    }\n\n    return null;\n  };\n\n  var getPathAndParamsForRoute = function getPathAndParamsForRoute(route) {\n    var routeName = route.routeName,\n        params = route.params;\n    var childRouter = childRouters[routeName];\n    var _pathsByRouteNames$ro = pathsByRouteNames[routeName],\n        toPath = _pathsByRouteNames$ro.toPath,\n        exactReKeys = _pathsByRouteNames$ro.exactReKeys;\n    var subPath = toPath(params);\n    var nonPathParams = {};\n\n    if (params) {\n      Object.keys(params).filter(function (paramName) {\n        return !exactReKeys.find(function (k) {\n          return k.name === paramName;\n        });\n      }).forEach(function (paramName) {\n        nonPathParams[paramName] = params[paramName];\n      });\n    }\n\n    if (childRouter) {\n      var child = childRouter.getPathAndParamsForState(route);\n      return {\n        path: subPath ? \"\".concat(subPath, \"/\").concat(child.path) : child.path,\n        params: child.params ? _objectSpread({}, nonPathParams, {}, child.params) : nonPathParams\n      };\n    }\n\n    return {\n      path: subPath,\n      params: nonPathParams\n    };\n  };\n\n  return {\n    getActionForPathAndParams: getActionForPathAndParams,\n    getPathAndParamsForRoute: getPathAndParamsForRoute\n  };\n};","map":{"version":3,"mappings":"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","names":["pathToRegexp","compile","NavigationActions","invariant","queryString","require","getParamsFromPath","inputParams","pathMatch","pathMatchKeys","params","slice","reduce","paramsOut","matchResult","i","key","asterisk","paramName","name","decodedMatchResult","decodeURIComponent","e","getRestOfPath","rest","findIndex","k","determineDelimiter","uri","uriPrefix","Array","isArray","length","prefix","startsWith","urlToPathAndParams","url","searchMatch","match","urlWithoutQuery","query","parse","delimiter","path","split","undefined","createPathParser","childRouters","routeConfigs","paths","pathConfigs","disableRouteNamePaths","pathsByRouteNames","Object","keys","forEach","routeName","pathPattern","isPathMatchable","exactReKeys","exactRe","extendedPathReKeys","isWildcard","extendedPathRe","toPath","entries","getActionForPathAndParams","pathToResolve","childRouter","exactMatch","exec","extendedMatch","childAction","restOfPath","navigate","action","getPathAndParamsForRoute","route","subPath","nonPathParams","filter","find","child","getPathAndParamsForState"],"sources":["pathUtils.js"],"sourcesContent":["/* eslint-disable import/no-commonjs */\n\nimport pathToRegexp, { compile } from 'path-to-regexp';\nimport * as NavigationActions from '../NavigationActions';\nimport invariant from '../utils/invariant';\n\nconst queryString = require('query-string');\n\nexport const getParamsFromPath = (inputParams, pathMatch, pathMatchKeys) => {\n  const params = pathMatch.slice(1).reduce(\n    // iterate over matched path params\n    (paramsOut, matchResult, i) => {\n      const key = pathMatchKeys[i];\n      if (!key || key.asterisk) {\n        return paramsOut;\n      }\n      const paramName = key.name;\n\n      let decodedMatchResult;\n      if (matchResult) {\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {\n          // ignore `URIError: malformed URI`\n        }\n      }\n\n      paramsOut[paramName] = decodedMatchResult || matchResult;\n      return paramsOut;\n    },\n    {\n      // start with the input(query string) params, which will get overridden by path params\n      ...inputParams,\n    }\n  );\n  return params;\n};\nconst getRestOfPath = (pathMatch, pathMatchKeys) => {\n  const rest = pathMatch[pathMatchKeys.findIndex((k) => k.asterisk) + 1];\n  return rest;\n};\n\nconst determineDelimiter = (uri, uriPrefix) => {\n  if (Array.isArray(uriPrefix)) {\n    if (uriPrefix.length === 1) return uriPrefix[0];\n    for (let prefix of uriPrefix) {\n      if (uri.startsWith(prefix)) return prefix;\n    }\n    return null;\n  }\n  return uriPrefix;\n};\n\nexport const urlToPathAndParams = (url, uriPrefix) => {\n  const searchMatch = url.match(/^(.*)\\?(.*)$/);\n  const [, urlWithoutQuery, query] = searchMatch || [null, url, {}];\n  const params = queryString.parse(query);\n  const delimiter = determineDelimiter(urlWithoutQuery, uriPrefix) || '://';\n  let path = urlWithoutQuery.split(delimiter)[1];\n  if (path === undefined) {\n    path = urlWithoutQuery;\n  }\n  if (path === '/') {\n    path = '';\n  }\n  if (path[path.length - 1] === '/') {\n    path = path.slice(0, -1);\n  }\n  return {\n    path,\n    params,\n  };\n};\n\nexport const createPathParser = (\n  childRouters,\n  routeConfigs,\n  { paths: pathConfigs = {}, disableRouteNamePaths }\n) => {\n  const pathsByRouteNames = {};\n  let paths = [];\n\n  // Build pathsByRouteNames, which includes a regex to match paths for each route. Keep in mind, the regex will pass for the route and all child routes. The code that uses pathsByRouteNames will need to also verify that the child router produces an action, in the case of isPathMatchable false (a null path).\n  Object.keys(childRouters).forEach((routeName) => {\n    let pathPattern;\n\n    // First check for paths on the router, then check the route config\n    if (pathConfigs[routeName] !== undefined) {\n      pathPattern = pathConfigs[routeName];\n    } else {\n      pathPattern = routeConfigs[routeName].path;\n    }\n\n    if (pathPattern === undefined) {\n      // If the user hasn't specified a path at all nor disableRouteNamePaths, then we assume the routeName is an appropriate path\n      pathPattern = disableRouteNamePaths ? null : routeName;\n    }\n\n    invariant(\n      pathPattern === null || typeof pathPattern === 'string',\n      `Route path for ${routeName} must be specified as a string, or null.`\n    );\n\n    // the path may be specified as null, which is similar to empty string because it allows child routers to handle the action, but it will not match empty paths\n    const isPathMatchable = pathPattern !== null;\n    // pathPattern is a string with inline params, such as people/:id/*foo\n    const exactReKeys = [];\n    const exactRe = isPathMatchable\n      ? pathToRegexp(pathPattern, exactReKeys)\n      : null;\n    const extendedPathReKeys = [];\n    const isWildcard = pathPattern === '' || !isPathMatchable;\n    const extendedPathRe = pathToRegexp(\n      isWildcard ? '*' : `${pathPattern}/*`,\n      extendedPathReKeys\n    );\n\n    pathsByRouteNames[routeName] = {\n      exactRe,\n      exactReKeys,\n      extendedPathRe,\n      extendedPathReKeys,\n      isWildcard,\n      toPath: pathPattern === null ? () => '' : compile(pathPattern),\n    };\n  });\n\n  paths = Object.entries(pathsByRouteNames);\n\n  const getActionForPathAndParams = (pathToResolve = '', inputParams = {}) => {\n    // Attempt to match `pathToResolve` with a route in this router's routeConfigs, deferring to child routers\n\n    for (const [routeName, path] of paths) {\n      const { exactRe, exactReKeys, extendedPathRe, extendedPathReKeys } = path;\n      const childRouter = childRouters[routeName];\n\n      const exactMatch = exactRe && exactRe.exec(pathToResolve);\n\n      if (exactMatch && exactMatch.length) {\n        const extendedMatch =\n          extendedPathRe && extendedPathRe.exec(pathToResolve);\n        let childAction = null;\n        if (extendedMatch && childRouter) {\n          const restOfPath = getRestOfPath(extendedMatch, extendedPathReKeys);\n          childAction = childRouter.getActionForPathAndParams(\n            restOfPath,\n            inputParams\n          );\n        }\n\n        return NavigationActions.navigate({\n          routeName,\n          params: getParamsFromPath(inputParams, exactMatch, exactReKeys),\n          action: childAction,\n        });\n      }\n    }\n\n    for (const [routeName, path] of paths) {\n      const { extendedPathRe, extendedPathReKeys } = path;\n      const childRouter = childRouters[routeName];\n\n      const extendedMatch =\n        extendedPathRe && extendedPathRe.exec(pathToResolve);\n\n      if (extendedMatch && extendedMatch.length) {\n        const restOfPath = getRestOfPath(extendedMatch, extendedPathReKeys);\n        let childAction = null;\n        if (childRouter) {\n          childAction = childRouter.getActionForPathAndParams(\n            restOfPath,\n            inputParams\n          );\n        }\n        if (!childAction) {\n          continue;\n        }\n        return NavigationActions.navigate({\n          routeName,\n          params: getParamsFromPath(\n            inputParams,\n            extendedMatch,\n            extendedPathReKeys\n          ),\n          action: childAction,\n        });\n      }\n    }\n\n    return null;\n  };\n  const getPathAndParamsForRoute = (route) => {\n    const { routeName, params } = route;\n    const childRouter = childRouters[routeName];\n    const { toPath, exactReKeys } = pathsByRouteNames[routeName];\n    const subPath = toPath(params);\n    const nonPathParams = {};\n    if (params) {\n      Object.keys(params)\n        .filter((paramName) => !exactReKeys.find((k) => k.name === paramName))\n        .forEach((paramName) => {\n          nonPathParams[paramName] = params[paramName];\n        });\n    }\n    if (childRouter) {\n      // If it has a router it's a navigator.\n      // If it doesn't have router it's an ordinary React component.\n      const child = childRouter.getPathAndParamsForState(route);\n      return {\n        path: subPath ? `${subPath}/${child.path}` : child.path,\n        params: child.params\n          ? { ...nonPathParams, ...child.params }\n          : nonPathParams,\n      };\n    }\n    return {\n      path: subPath,\n      params: nonPathParams,\n    };\n  };\n  return { getActionForPathAndParams, getPathAndParamsForRoute };\n};\n"]},"metadata":{},"sourceType":"module"}