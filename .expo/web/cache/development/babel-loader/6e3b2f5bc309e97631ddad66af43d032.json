{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport View from \"react-native-web/dist/exports/View\";\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Svg, { Defs, Stop, G, Path, LinearGradient, Circle } from 'react-native-svg';\nimport { arc } from 'd3-shape';\nimport range from 'lodash/range';\nimport convert from 'color-convert';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nfunction calculateStopColor(i, beginColor, endColor, segments) {\n  return [Math.round(beginColor[0] + (endColor[0] - beginColor[0]) * i / segments), Math.round(beginColor[1] + (endColor[1] - beginColor[1]) * i / segments), Math.round(beginColor[2] + (endColor[2] - beginColor[2]) * i / segments)];\n}\n\nvar LINEAR_GRADIENT_PREFIX_ID = 'gradientRing';\n\nvar CircularProgress = function (_Component) {\n  _inherits(CircularProgress, _Component);\n\n  _createClass(CircularProgress, null, [{\n    key: \"renderLinearGradients\",\n    value: function renderLinearGradients(state) {\n      var r1 = state.r1,\n          beginColor = state.beginColor,\n          endColor = state.endColor,\n          segments = state.segments;\n      var startColor = beginColor;\n      var stopColor = calculateStopColor(1, beginColor, endColor, segments);\n      var startAngle = 0;\n      var stopAngle = 2 * Math.PI / segments;\n      return range(1, segments + 1).map(function (i) {\n        var linearGradient = _jsxs(LinearGradient, {\n          id: LINEAR_GRADIENT_PREFIX_ID + i,\n          x1: r1 * Math.sin(startAngle),\n          y1: -r1 * Math.cos(startAngle),\n          x2: r1 * Math.sin(stopAngle),\n          y2: -r1 * Math.cos(stopAngle),\n          children: [_jsx(Stop, {\n            offset: \"0\",\n            stopColor: 'rgb(' + startColor.join(',') + ')'\n          }), _jsx(Stop, {\n            offset: \"1\",\n            stopColor: 'rgb(' + stopColor.join(',') + ')'\n          })]\n        }, LINEAR_GRADIENT_PREFIX_ID + i);\n\n        startColor = stopColor;\n        stopColor = calculateStopColor(i + 1, beginColor, endColor, segments);\n        startAngle = stopAngle;\n        stopAngle += 2 * Math.PI / segments;\n        return linearGradient;\n      });\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var width = nextProps.width,\n          size = nextProps.size,\n          beginColor = nextProps.beginColor,\n          endColor = nextProps.endColor,\n          segments = nextProps.segments;\n      var nextState = {};\n\n      if (segments !== prevState.segments) {\n        nextState.segments = segments;\n      }\n\n      if (width !== prevState.width || size !== prevState.size) {\n        var r2 = size / 2;\n        nextState = _objectSpread({}, nextState, {\n          r1: r2 - width,\n          r2: r2,\n          width: width,\n          size: size\n        });\n      }\n\n      if (beginColor !== prevState.beginColorCached || endColor !== prevState.endColorCached) {\n        nextState = _objectSpread({}, nextState, {\n          beginColorCached: beginColor,\n          endColorCached: endColor,\n          beginColor: convert.hex.rgb(endColor),\n          endColor: convert.hex.rgb(beginColor)\n        });\n      }\n\n      var keys = Object.keys(nextState);\n\n      if (keys.length) {\n        var combinedState = _objectSpread({}, prevState, {}, nextState);\n\n        nextState.linearGradients = CircularProgress.renderLinearGradients(combinedState);\n      }\n\n      return keys.length ? nextState : null;\n    }\n  }]);\n\n  function CircularProgress(props) {\n    var _this;\n\n    _classCallCheck(this, CircularProgress);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CircularProgress).call(this, props));\n    _this.state = {};\n    _this.animatedValue = new Animated.Value(0);\n    _this.value = 0;\n\n    _this.animatedValue.addListener(function (_ref) {\n      var value = _ref.value;\n      _this.value = value;\n    });\n\n    return _this;\n  }\n\n  _createClass(CircularProgress, [{\n    key: \"extractFill\",\n    value: function extractFill() {\n      return Math.min(100, Math.max(0, this.props.fill));\n    }\n  }, {\n    key: \"renderBackgroundPath\",\n    value: function renderBackgroundPath() {\n      var _this$state = this.state,\n          r1 = _this$state.r1,\n          r2 = _this$state.r2;\n      var _this$props = this.props,\n          size = _this$props.size,\n          width = _this$props.width,\n          backgroundColor = _this$props.backgroundColor;\n      var backgroundPath = arc().innerRadius(r1).outerRadius(r2).startAngle(0).endAngle(2 * Math.PI);\n      return _jsx(Path, {\n        x: size / 2,\n        y: size / 2,\n        d: backgroundPath(),\n        fill: backgroundColor\n      });\n    }\n  }, {\n    key: \"renderCirclePaths\",\n    value: function renderCirclePaths() {\n      var _this2 = this;\n\n      var _this$state2 = this.state,\n          r1 = _this$state2.r1,\n          r2 = _this$state2.r2,\n          segments = _this$state2.segments;\n      var _this$props2 = this.props,\n          size = _this$props2.size,\n          width = _this$props2.width,\n          beginColor = _this$props2.beginColor;\n      var fill = this.extractFill();\n      var numberOfPathsToDraw = Math.floor(2 * Math.PI * (fill / 100) / (2 * Math.PI / segments));\n      var rem = 2 * Math.PI * (fill / 100) / (2 * Math.PI / segments) % 1;\n\n      if (rem > 0) {\n        numberOfPathsToDraw++;\n      }\n\n      var startAngle = 0;\n      var stopAngle = -(2 * Math.PI) / segments;\n      return [_jsx(Circle, {\n        cx: size / 2,\n        cy: width / 2,\n        r: width / 2,\n        fill: beginColor\n      }, \"start_circle\")].concat(_toConsumableArray(range(1, numberOfPathsToDraw + 1).map(function (i) {\n        if (i === numberOfPathsToDraw && rem) {\n          stopAngle = -2 * Math.PI * (fill / 100);\n        }\n\n        var circlePath = arc().innerRadius(r1).outerRadius(r2).startAngle(startAngle).endAngle(stopAngle - 0.005);\n\n        var path = _jsx(Path, {\n          x: _this2.props.size / 2,\n          y: _this2.props.size / 2,\n          d: circlePath(),\n          fill: 'url(#' + LINEAR_GRADIENT_PREFIX_ID + (segments - i + 1) + ')'\n        }, fill + i);\n\n        startAngle = stopAngle;\n        stopAngle -= 2 * Math.PI / segments;\n        return path;\n      })), [_jsx(Circle, {\n        cx: (r2 - (r2 - r1) / 2) * Math.sin(2 * Math.PI * (fill / 100) - Math.PI) + size / 2,\n        cy: (r2 - (r2 - r1) / 2) * Math.cos(2 * Math.PI * (fill / 100) - Math.PI) + size / 2,\n        r: width / 2,\n        fill: 'rgb(' + calculateStopColor(this.extractFill(), this.state.endColor, this.state.beginColor, 100).join(',') + ')'\n      }, \"end_circle\")]);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          size = _this$props3.size,\n          rotation = _this$props3.rotation,\n          style = _this$props3.style,\n          children = _this$props3.children;\n      var linearGradients = this.state.linearGradients;\n      var fill = this.extractFill();\n      this.SetInterpolate = this.animatedValue.interpolate({\n        inputRange: [0, 180],\n        outputRange: ['180deg', '360deg']\n      });\n      var Rotate_Y_AnimatedStyle = {\n        transform: [{\n          rotateY: this.SetInterpolate\n        }]\n      };\n      return _jsxs(Animated.View, {\n        style: [style, Rotate_Y_AnimatedStyle],\n        children: [_jsxs(Svg, {\n          width: size,\n          height: size,\n          children: [_jsx(Defs, {\n            children: linearGradients\n          }, \"linear_gradients\"), _jsxs(G, {\n            rotation: 0,\n            originX: size / 2,\n            originY: size / 2,\n            children: [this.renderBackgroundPath(), this.renderCirclePaths()]\n          })]\n        }), children && children(fill)]\n      });\n    }\n  }]);\n\n  return CircularProgress;\n}(Component);\n\nexport { CircularProgress as default };\nCircularProgress.propTypes = {\n  backgroundColor: PropTypes.string,\n  children: PropTypes.func,\n  fill: PropTypes.number.isRequired,\n  rotation: PropTypes.number,\n  size: PropTypes.number.isRequired,\n  style: ViewPropTypes.style,\n  tintColor: PropTypes.string,\n  width: PropTypes.number.isRequired,\n  linecap: PropTypes.string\n};\nCircularProgress.defaultProps = {\n  tintColor: 'black',\n  backgroundColor: '#e4e4e4',\n  rotation: 90,\n  linecap: 'butt'\n};","map":{"version":3,"sources":["/home/codenomad/Documents/flicknplayreacttv/node_modules/react-native-video-players/src/VideoPlayerComponents/gradientProgress/src/CircularProgress.js"],"names":["React","Component","PropTypes","ViewPropTypes","Svg","Defs","Stop","G","Path","LinearGradient","Circle","arc","range","convert","calculateStopColor","i","beginColor","endColor","segments","Math","round","LINEAR_GRADIENT_PREFIX_ID","CircularProgress","state","r1","startColor","stopColor","startAngle","stopAngle","PI","map","linearGradient","sin","cos","join","nextProps","prevState","width","size","nextState","r2","beginColorCached","endColorCached","hex","rgb","keys","Object","length","combinedState","linearGradients","renderLinearGradients","props","animatedValue","Animated","Value","value","addListener","min","max","fill","backgroundColor","backgroundPath","innerRadius","outerRadius","endAngle","extractFill","numberOfPathsToDraw","floor","rem","circlePath","path","rotation","style","children","SetInterpolate","interpolate","inputRange","outputRange","Rotate_Y_AnimatedStyle","transform","rotateY","renderBackgroundPath","renderCirclePaths","propTypes","string","func","number","isRequired","tintColor","linecap","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { View, ViewPropTypes, Animated } from 'react-native';\r\nimport Svg, { Defs, Stop, G, Path, LinearGradient, Circle } from 'react-native-svg';\r\nimport { arc } from 'd3-shape';\r\nimport range from 'lodash/range';\r\nimport convert from 'color-convert';\r\n\r\nfunction calculateStopColor(i, beginColor, endColor, segments) {\r\n  return [\r\n    Math.round(beginColor[0] + ((endColor[0] - beginColor[0]) * i) / segments),\r\n    Math.round(beginColor[1] + ((endColor[1] - beginColor[1]) * i) / segments),\r\n    Math.round(beginColor[2] + ((endColor[2] - beginColor[2]) * i) / segments),\r\n  ];\r\n}\r\n\r\nconst LINEAR_GRADIENT_PREFIX_ID = 'gradientRing';\r\n\r\nexport default class CircularProgress extends Component {\r\n  static renderLinearGradients(state) {\r\n    const { r1, beginColor, endColor, segments } = state;\r\n    let startColor = beginColor;\r\n    let stopColor = calculateStopColor(1, beginColor, endColor, segments);\r\n    let startAngle = 0;\r\n    let stopAngle = (2 * Math.PI) / segments;\r\n\r\n    return range(1, segments + 1).map(i => {\r\n      const linearGradient = (\r\n        <LinearGradient\r\n          id={LINEAR_GRADIENT_PREFIX_ID + i}\r\n          key={LINEAR_GRADIENT_PREFIX_ID + i}\r\n          x1={r1 * Math.sin(startAngle)}\r\n          y1={-r1 * Math.cos(startAngle)}\r\n          x2={r1 * Math.sin(stopAngle)}\r\n          y2={-r1 * Math.cos(stopAngle)}\r\n        >\r\n          <Stop offset=\"0\" stopColor={'rgb(' + startColor.join(',') + ')'} />\r\n          <Stop offset=\"1\" stopColor={'rgb(' + stopColor.join(',') + ')'} />\r\n        </LinearGradient>\r\n      );\r\n      startColor = stopColor;\r\n      stopColor = calculateStopColor(i + 1, beginColor, endColor, segments);\r\n      startAngle = stopAngle;\r\n      stopAngle += (2 * Math.PI) / segments;\r\n\r\n      return linearGradient;\r\n    });\r\n  }\r\n\r\n  static getDerivedStateFromProps(nextProps, prevState) {\r\n    const { width, size, beginColor, endColor, segments } = nextProps;\r\n    let nextState = {};\r\n\r\n    if (segments !== prevState.segments) {\r\n      nextState.segments = segments;\r\n    }\r\n\r\n    if (width !== prevState.width || size !== prevState.size) {\r\n      const r2 = size / 2;\r\n      nextState = {\r\n        ...nextState,\r\n        r1: r2 - width,\r\n        r2,\r\n        width,\r\n        size,\r\n      };\r\n    }\r\n\r\n    if (beginColor !== prevState.beginColorCached || endColor !== prevState.endColorCached) {\r\n      // CHANGE COLOR ORDER\r\n      nextState = {\r\n        ...nextState,\r\n        beginColorCached: beginColor,\r\n        endColorCached: endColor,\r\n        beginColor: convert.hex.rgb(endColor),\r\n        endColor: convert.hex.rgb(beginColor),\r\n      };\r\n    }\r\n\r\n    const keys = Object.keys(nextState);\r\n\r\n    if (keys.length) {\r\n      const combinedState = { ...prevState, ...nextState };\r\n      nextState.linearGradients = CircularProgress.renderLinearGradients(combinedState);\r\n    }\r\n    return keys.length ? nextState : null;\r\n  }\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n\r\n    this.animatedValue = new Animated.Value(0);\r\n    this.value = 0;\r\n    this.animatedValue.addListener(({ value }) => {\r\n      this.value = value;\r\n    });\r\n  }\r\n\r\n  extractFill() {\r\n    return Math.min(100, Math.max(0, this.props.fill));\r\n  }\r\n\r\n  renderBackgroundPath() {\r\n    const { r1, r2 } = this.state;\r\n    const { size, width, backgroundColor } = this.props;\r\n    const backgroundPath = arc()\r\n      .innerRadius(r1)\r\n      .outerRadius(r2)\r\n      .startAngle(0)\r\n      .endAngle(2 * Math.PI);\r\n\r\n    return <Path x={size / 2} y={size / 2} d={backgroundPath()} fill={backgroundColor} />;\r\n  }\r\n\r\n  renderCirclePaths() {\r\n    const { r1, r2, segments } = this.state;\r\n    const { size, width, beginColor } = this.props;\r\n    const fill = this.extractFill();\r\n\r\n    let numberOfPathsToDraw = Math.floor((2 * Math.PI * (fill / 100)) / ((2 * Math.PI) / segments));\r\n    let rem = ((2 * Math.PI * (fill / 100)) / ((2 * Math.PI) / segments)) % 1;\r\n    if (rem > 0) {\r\n      numberOfPathsToDraw++;\r\n    }\r\n    let startAngle = 0;\r\n    let stopAngle = -(2 * Math.PI) / segments;\r\n\r\n    return [\r\n      <Circle key=\"start_circle\" cx={size / 2} cy={width / 2} r={width / 2} fill={beginColor} />,\r\n      ...range(1, numberOfPathsToDraw + 1).map(i => {\r\n        if (i === numberOfPathsToDraw && rem) {\r\n          stopAngle = -2 * Math.PI * (fill / 100);\r\n        }\r\n        const circlePath = arc()\r\n          .innerRadius(r1)\r\n          .outerRadius(r2)\r\n          .startAngle(startAngle)\r\n          .endAngle(stopAngle - 0.005);\r\n\r\n        const path = (\r\n          <Path\r\n            x={this.props.size / 2}\r\n            y={this.props.size / 2}\r\n            key={fill + i}\r\n            d={circlePath()}\r\n            fill={'url(#' + LINEAR_GRADIENT_PREFIX_ID + (segments - i + 1) + ')'}\r\n          />\r\n        );\r\n        startAngle = stopAngle;\r\n        stopAngle -= (2 * Math.PI) / segments;\r\n\r\n        return path;\r\n      }),\r\n      <Circle\r\n        key=\"end_circle\"\r\n        cx={(r2 - (r2 - r1) / 2) * Math.sin(2 * Math.PI * (fill / 100) - Math.PI) + size / 2}\r\n        cy={(r2 - (r2 - r1) / 2) * Math.cos(2 * Math.PI * (fill / 100) - Math.PI) + size / 2}\r\n        r={width / 2}\r\n        fill={\r\n          'rgb(' +\r\n          calculateStopColor(\r\n            this.extractFill(),\r\n            this.state.endColor,\r\n            this.state.beginColor,\r\n            100\r\n          ).join(',') +\r\n          ')'\r\n        }\r\n      />,\r\n    ];\r\n  }\r\n\r\n  render() {\r\n    const { size, rotation, style, children } = this.props;\r\n    const { linearGradients } = this.state;\r\n    const fill = this.extractFill();\r\n\r\n    this.SetInterpolate = this.animatedValue.interpolate({\r\n      inputRange: [0, 180],\r\n      outputRange: ['180deg', '360deg'],\r\n    });\r\n    const Rotate_Y_AnimatedStyle = {\r\n      transform: [{ rotateY: this.SetInterpolate }],\r\n    };\r\n\r\n    return (\r\n      <Animated.View style={[style, Rotate_Y_AnimatedStyle]}>\r\n        <Svg width={size} height={size}>\r\n          <Defs key=\"linear_gradients\">{linearGradients}</Defs>\r\n          <G rotation={0} originX={size / 2} originY={size / 2}>\r\n            {this.renderBackgroundPath()}\r\n            {this.renderCirclePaths()}\r\n          </G>\r\n        </Svg>\r\n        {children && children(fill)}\r\n      </Animated.View>\r\n    );\r\n  }\r\n}\r\n\r\nCircularProgress.propTypes = {\r\n  backgroundColor: PropTypes.string,\r\n  children: PropTypes.func,\r\n  fill: PropTypes.number.isRequired,\r\n  rotation: PropTypes.number,\r\n  size: PropTypes.number.isRequired,\r\n  style: ViewPropTypes.style,\r\n  tintColor: PropTypes.string,\r\n  width: PropTypes.number.isRequired,\r\n  linecap: PropTypes.string,\r\n};\r\n\r\nCircularProgress.defaultProps = {\r\n  tintColor: 'black',\r\n  backgroundColor: '#e4e4e4',\r\n  rotation: 90,\r\n  linecap: 'butt',\r\n};\r\n"]},"metadata":{},"sourceType":"module"}