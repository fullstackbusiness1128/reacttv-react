{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React, { Component } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport ActivityIndicator from \"react-native-web/dist/exports/ActivityIndicator\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport styles from \"./ParallaxImage.style\";\nexport var ParallaxImageStatus;\n\n(function (ParallaxImageStatus) {\n  ParallaxImageStatus[ParallaxImageStatus[\"LOADING\"] = 1] = \"LOADING\";\n  ParallaxImageStatus[ParallaxImageStatus[\"LOADED\"] = 2] = \"LOADED\";\n  ParallaxImageStatus[ParallaxImageStatus[\"TRANSITION_FINISHED\"] = 3] = \"TRANSITION_FINISHED\";\n  ParallaxImageStatus[ParallaxImageStatus[\"ERROR\"] = 4] = \"ERROR\";\n})(ParallaxImageStatus || (ParallaxImageStatus = {}));\n\nvar ParallaxImage = function (_Component) {\n  _inherits(ParallaxImage, _Component);\n\n  function ParallaxImage(props) {\n    var _this;\n\n    _classCallCheck(this, ParallaxImage);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParallaxImage).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"_container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_mounted\", void 0);\n\n    _this.state = {\n      offset: 0,\n      width: 0,\n      height: 0,\n      status: ParallaxImageStatus.LOADING,\n      animOpacity: new Animated.Value(0)\n    };\n    _this._onLoad = _this._onLoad.bind(_assertThisInitialized(_this));\n    _this._onError = _this._onError.bind(_assertThisInitialized(_this));\n    _this._measureLayout = _this._measureLayout.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ParallaxImage, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(nativeProps) {\n      var _this$_container;\n\n      (_this$_container = this._container) === null || _this$_container === void 0 ? void 0 : _this$_container.setNativeProps(nativeProps);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this._mounted = true;\n      setTimeout(function () {\n        _this2._measureLayout();\n      }, 0);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n    }\n  }, {\n    key: \"_measureLayout\",\n    value: function _measureLayout() {\n      var _this3 = this;\n\n      if (this._container) {\n        var _this$props = this.props,\n            dimensions = _this$props.dimensions,\n            carouselRef = _this$props.carouselRef;\n        var nodeHandle = findNodeHandle(carouselRef);\n\n        if (carouselRef && nodeHandle) {\n          this._container.measureLayout(nodeHandle, function (x, y, width, height) {\n            var offset = _this3.props.vertical ? y - (_this3.props.sliderHeight - _this3.props.itemHeight) / 2 : x - (_this3.props.sliderWidth - _this3.props.itemWidth) / 2;\n\n            _this3.setState({\n              offset: offset,\n              width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),\n              height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)\n            });\n          }, function () {});\n        }\n      }\n    }\n  }, {\n    key: \"_onLoad\",\n    value: function _onLoad(event) {\n      var _this4 = this;\n\n      var animOpacity = this.state.animOpacity;\n      var _this$props2 = this.props,\n          fadeDuration = _this$props2.fadeDuration,\n          onLoad = _this$props2.onLoad;\n\n      if (!this._mounted) {\n        return;\n      }\n\n      this.setState({\n        status: ParallaxImageStatus.LOADED\n      });\n\n      if (onLoad) {\n        onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n        toValue: 1,\n        duration: fadeDuration,\n        easing: Easing.out(Easing.quad),\n        isInteraction: false,\n        useNativeDriver: true\n      }).start(function () {\n        _this4.setState({\n          status: ParallaxImageStatus.TRANSITION_FINISHED\n        });\n      });\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(event) {\n      var onError = this.props.onError;\n      this.setState({\n        status: ParallaxImageStatus.ERROR\n      });\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var containerStyle = this.props.containerStyle;\n      return React.createElement(View, {\n        ref: function ref(c) {\n          _this5._container = c;\n        },\n        pointerEvents: \"none\",\n        style: [containerStyle, styles.container],\n        onLayout: this._measureLayout\n      }, this.image, this.spinner);\n    }\n  }, {\n    key: \"image\",\n    get: function get() {\n      var _this$state = this.state,\n          status = _this$state.status,\n          animOpacity = _this$state.animOpacity,\n          offset = _this$state.offset,\n          width = _this$state.width,\n          height = _this$state.height;\n\n      var _this$props3 = this.props,\n          scrollPosition = _this$props3.scrollPosition,\n          dimensions = _this$props3.dimensions,\n          parallaxFactor = _this$props3.parallaxFactor,\n          style = _this$props3.style,\n          AnimatedImageComponent = _this$props3.AnimatedImageComponent,\n          other = _objectWithoutProperties(_this$props3, [\"scrollPosition\", \"dimensions\", \"parallaxFactor\", \"style\", \"AnimatedImageComponent\"]);\n\n      var parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      var requiredStyles = {\n        position: 'relative'\n      };\n      var dynamicStyles = {\n        width: this.props.vertical ? width : width + parallaxPadding * 2,\n        height: this.props.vertical ? height + parallaxPadding * 2 : height,\n        opacity: animOpacity,\n        transform: scrollPosition ? [{\n          translateX: !this.props.vertical ? scrollPosition.interpolate({\n            inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n            outputRange: [-parallaxPadding, parallaxPadding],\n            extrapolate: 'clamp'\n          }) : 0\n        }, {\n          translateY: this.props.vertical ? scrollPosition.interpolate({\n            inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n            outputRange: [-parallaxPadding, parallaxPadding],\n            extrapolate: 'clamp'\n          }) : 0\n        }] : []\n      };\n      return React.createElement(AnimatedImageComponent, _extends({}, other, {\n        style: [styles.image, style, requiredStyles, dynamicStyles],\n        onLoad: this._onLoad,\n        onError: status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined\n      }));\n    }\n  }, {\n    key: \"spinner\",\n    get: function get() {\n      var status = this.state.status;\n      var _this$props4 = this.props,\n          showSpinner = _this$props4.showSpinner,\n          spinnerColor = _this$props4.spinnerColor;\n      return status === ParallaxImageStatus.LOADING && showSpinner ? React.createElement(View, {\n        style: styles.loaderContainer\n      }, React.createElement(ActivityIndicator, {\n        size: \"small\",\n        color: spinnerColor,\n        animating: true\n      })) : false;\n    }\n  }]);\n\n  return ParallaxImage;\n}(Component);\n\nexport { ParallaxImage as default };\n\n_defineProperty(ParallaxImage, \"defaultProps\", {\n  containerStyle: {},\n  fadeDuration: 500,\n  parallaxFactor: 0.3,\n  showSpinner: true,\n  spinnerColor: 'rgba(0, 0, 0, 0.4)',\n  AnimatedImageComponent: Animated.Image\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;;;;;;AAcA,OAAOC,MAAP;AA4BA,WAAYC,mBAAZ;;WAAYA,qB;EAAAA,mB,CAAAA,mB,WAAAA,G,EAAAA,G,SAAAA;EAAAA,mB,CAAAA,mB,UAAAA,G,EAAAA,G,QAAAA;EAAAA,mB,CAAAA,mB,uBAAAA,G,EAAAA,G,qBAAAA;EAAAA,mB,CAAAA,mB,SAAAA,G,EAAAA,G,OAAAA;GAAAA,mB,KAAAA,mB;;IAeSC,a;;;EAgBnBC,uBAAaC,KAAbD,EAAwC;IAAA;;IAAA;;IACpC,mFAAMC,KAAN;;IADoCC;;IAAAA;;IAEpC,MAAKC,KAAL,GAAa;MACTC,MAAM,EAAE,CADC;MAETC,KAAK,EAAE,CAFE;MAGTC,MAAM,EAAE,CAHC;MAITC,MAAM,EAAET,mBAAmB,CAACU,OAJnB;MAKTC,WAAW,EAAE,IAAIC,QAAQ,CAACC,KAAb,CAAmB,CAAnB;IALJ,CAAb;IAOA,MAAKC,OAAL,GAAe,MAAKA,OAAL,CAAaC,IAAb,+BAAf;IACA,MAAKC,QAAL,GAAgB,MAAKA,QAAL,CAAcD,IAAd,+BAAhB;IACA,MAAKE,cAAL,GAAsB,MAAKA,cAAL,CAAoBF,IAApB,+BAAtB;IAXoC;EAYvC;;;;mCAEeG,W,EAAyC;MAAA;;MACvD,yBAAKC,UAAL,sEAAiBC,cAAjB,CAAgCF,WAAhC;IACD;;;wCAEoB;MAAA;;MACjB,KAAKG,QAAL,GAAgB,IAAhB;MAEAC,UAAU,CAAC,YAAM;QACb,OAAKL,cAAL;MADM,GAEP,CAFO,CAAVK;IAGH;;;2CAEuB;MACpB,KAAKD,QAAL,GAAgB,KAAhB;IACH;;;qCAEiB;MAAA;;MACd,IAAI,KAAKF,UAAT,EAAqB;QAAA,kBAIb,KAAKhB,KAJQ;QAAA,IAEboB,UAFa,eAEbA,UAFa;QAAA,IAGbC,WAHa,eAGbA,WAHa;QAMjB,IAAMC,UAAU,GAAGC,cAAc,CAACF,WAAD,CAAjC;;QAEA,IAAIA,WAAW,IAAIC,UAAnB,EAA+B;UAC3B,KAAKN,UAAL,CAAgBQ,aAAhB,CACIF,UADJ,EAEI,UAACG,CAAD,EAAIC,CAAJ,EAAOtB,KAAP,EAAcC,MAAd,EAAyB;YACrB,IAAMF,MAAM,GAAG,OAAKH,KAAL,CAAW2B,QAAX,GACXD,CAAC,GAAG,CAAC,OAAK1B,KAAL,CAAW4B,YAAX,GAA0B,OAAK5B,KAAL,CAAW6B,UAAtC,IAAoD,CAD7C,GAEXJ,CAAC,GAAG,CAAC,OAAKzB,KAAL,CAAW8B,WAAX,GAAyB,OAAK9B,KAAL,CAAW+B,SAArC,IAAkD,CAF1D;;YAIA,OAAKC,QAAL,CAAc;cACV7B,MAAM,EAAEA,MADE;cAEVC,KAAK,EACfgB,UAAU,IAAIA,UAAU,CAAChB,KAAzBgB,GACIA,UAAU,CAAChB,KADfgB,GAEIa,IAAI,CAACC,IAALD,CAAU7B,KAAV6B,CALgB;cAMV5B,MAAM,EAChBe,UAAU,IAAIA,UAAU,CAACf,MAAzBe,GACIA,UAAU,CAACf,MADfe,GAEIa,IAAI,CAACC,IAALD,CAAU5B,MAAV4B;YATgB,CAAd;UAPR,GAoBI,YAAM,CApBV;QAsBH;MACJ;IACJ;;;4BAEQE,K,EAAiD;MAAA;;MAAA,IAC9C3B,WAD8C,GAC9B,KAAKN,KADyB,CAC9CM,WAD8C;MAAA,mBAErB,KAAKR,KAFgB;MAAA,IAE9CoC,YAF8C,gBAE9CA,YAF8C;MAAA,IAEhCC,MAFgC,gBAEhCA,MAFgC;;MAItD,IAAI,CAAC,KAAKnB,QAAV,EAAoB;QAChB;MACH;;MAED,KAAKc,QAAL,CAAc;QAAE1B,MAAM,EAAET,mBAAmB,CAACyC;MAA9B,CAAd;;MAEA,IAAID,MAAJ,EAAY;QACRA,MAAM,CAACF,KAAD,CAANE;MACH;;MAED5B,QAAQ,CAAC8B,MAAT9B,CAAgBD,WAAhBC,EAA6B;QACzB+B,OAAO,EAAE,CADgB;QAEzBC,QAAQ,EAAEL,YAFe;QAGzBM,MAAM,EAAEC,MAAM,CAACC,GAAPD,CAAWA,MAAM,CAACE,IAAlBF,CAHiB;QAIzBG,aAAa,EAAE,KAJU;QAKzBC,eAAe,EAAE;MALQ,CAA7BtC,EAMGuC,KANHvC,CAMS,YAAM;QACX,OAAKuB,QAAL,CAAc;UAAE1B,MAAM,EAAET,mBAAmB,CAACoD;QAA9B,CAAd;MAPJ;IA7FJ;;;6BAyGUd,K,EAAkD;MAAA,IAChDe,OADgD,GACpC,KAAKlD,KAD+B,CAChDkD,OADgD;MAGxD,KAAKlB,QAAL,CAAc;QAAE1B,MAAM,EAAET,mBAAmB,CAACsD;MAA9B,CAAd;;MAEA,IAAID,OAAJ,EAAa;QACTA,OAAO,CAACf,KAAD,CAAPe;MACH;IACJ;;;6BAuES;MAAA;;MAAA,IACEE,cADF,GACqB,KAAKpD,KAD1B,CACEoD,cADF;MAGN,OACI1D,oBAAC2D,IAAD;QACEC,GAAG,EAAGC,cAAD,EAAO;UACR,OAAKvC,UAAL,GAAkBuC,CAAlB;QAFN;QAIEC,aAAa,EAAC,MAJhB;QAKEC,KAAK,EAAE,CAACL,cAAD,EAAiBxD,MAAM,CAAC8D,SAAxB,CALT;QAMEC,QAAQ,EAAE,KAAK7C;MANjB,GAQK,KAAK8C,KARV,EASK,KAAKC,OATV,CADJ;IAaH;;;wBArFY;MAAA,kBAC8C,KAAK3D,KADnD;MAAA,IACDI,MADC,eACDA,MADC;MAAA,IACOE,WADP,eACOA,WADP;MAAA,IACoBL,MADpB,eACoBA,MADpB;MAAA,IAC4BC,KAD5B,eAC4BA,KAD5B;MAAA,IACmCC,MADnC,eACmCA,MADnC;;MAAA,mBAWL,KAAKL,KAXA;MAAA,IAGL8D,cAHK,gBAGLA,cAHK;MAAA,IAML1C,UANK,gBAMLA,UANK;MAAA,IAOL2C,cAPK,gBAOLA,cAPK;MAAA,IAQLN,KARK,gBAQLA,KARK;MAAA,IASLO,sBATK,gBASLA,sBATK;MAAA,IAUFC,KAVE;;MAYT,IAAMC,eAAe,GAAG,CAAC,KAAKlE,KAAL,CAAW2B,QAAX,GAAsBtB,MAAtB,GAA+BD,KAAhC,IAAyC2D,cAAjE;MACA,IAAMI,cAAc,GAAG;QAAEC,QAAQ,EAAE;MAAZ,CAAvB;MACA,IAAMC,aAAa,GAAG;QAClBjE,KAAK,EAAE,KAAKJ,KAAL,CAAW2B,QAAX,GAAsBvB,KAAtB,GAA8BA,KAAK,GAAG8D,eAAe,GAAG,CAD7C;QAElB7D,MAAM,EAAE,KAAKL,KAAL,CAAW2B,QAAX,GAAsBtB,MAAM,GAAG6D,eAAe,GAAG,CAAjD,GAAqD7D,MAF3C;QAGlBiE,OAAO,EAAE9D,WAHS;QAIlB+D,SAAS,EAAET,cAAc,GACrB,CACI;UACIU,UAAU,EAAE,CAAC,KAAKxE,KAAL,CAAW2B,QAAZ,GACRmC,cAAc,CAACW,WAAfX,CAA2B;YACvBY,UAAU,EAAE,CAACvE,MAAM,GAAG,KAAKH,KAAL,CAAW8B,WAArB,EAAkC3B,MAAM,GAAG,KAAKH,KAAL,CAAW8B,WAAtD,CADW;YAEvB6C,WAAW,EAAE,CAAC,CAACT,eAAF,EAAmBA,eAAnB,CAFU;YAGvBU,WAAW,EAAE;UAHU,CAA3Bd,CADQ,GAMR;QAPR,CADJ,EAUI;UACIe,UAAU,EAAE,KAAK7E,KAAL,CAAW2B,QAAX,GACRmC,cAAc,CAACW,WAAfX,CAA2B;YACvBY,UAAU,EAAE,CAACvE,MAAM,GAAG,KAAKH,KAAL,CAAW4B,YAArB,EAAmCzB,MAAM,GAAG,KAAKH,KAAL,CAAW4B,YAAvD,CADW;YAEvB+C,WAAW,EAAE,CAAC,CAACT,eAAF,EAAmBA,eAAnB,CAFU;YAGvBU,WAAW,EAAE;UAHU,CAA3Bd,CADQ,GAMR;QAPR,CAVJ,CADqB,GAqBrB;MAzBc,CAAtB;MA4BA,OACIpE,oBAACsE,sBAAD,eACMC,KADN;QAEER,KAAK,EAAE,CAAC7D,MAAM,CAACgE,KAAR,EAAeH,KAAf,EAAsBU,cAAtB,EAAsCE,aAAtC,CAFT;QAGEhC,MAAM,EAAE,KAAK1B,OAHf;QAIEuC,OAAO,EAAE5C,MAAM,KAAKT,mBAAmB,CAACoD,mBAA/B3C,GAAqD,KAAKO,QAA1DP,GAAqEwE;MAJhF,GADJ;IAQH;;;wBAEc;MAAA,IACHxE,MADG,GACQ,KAAKJ,KADb,CACHI,MADG;MAAA,mBAE2B,KAAKN,KAFhC;MAAA,IAEH+E,WAFG,gBAEHA,WAFG;MAAA,IAEUC,YAFV,gBAEUA,YAFV;MAIX,OAAO1E,MAAM,KAAKT,mBAAmB,CAACU,OAA/BD,IAA0CyE,WAA1CzE,GACHZ,oBAAC2D,IAAD;QAAMI,KAAK,EAAE7D,MAAM,CAACqF;MAApB,GACIvF,oBAACwF,iBAAD;QACEC,IAAI,EAAC,OADP;QAEEC,KAAK,EAAEJ,YAFT;QAGEK,SAAS,EAAE;MAHb,EADJ,CADG/E,GASH,KATJ;IAWH;;;;EAzLwCX,S;;SAAtBG,a;;gBAAAA,e,gBAIG;EAClBsD,cAAc,EAAE,EADE;EAElBhB,YAAY,EAAE,GAFI;EAGlB2B,cAAc,EAAE,GAHE;EAIlBgB,WAAW,EAAE,IAJK;EAKlBC,YAAY,EAAE,oBALI;EAMlBhB,sBAAsB,EAAEvD,QAAQ,CAAC6E;AANf","names":["React","Component","styles","ParallaxImageStatus","ParallaxImage","constructor","props","_defineProperty","state","offset","width","height","status","LOADING","animOpacity","Animated","Value","_onLoad","bind","_onError","_measureLayout","nativeProps","_container","setNativeProps","_mounted","setTimeout","dimensions","carouselRef","nodeHandle","findNodeHandle","measureLayout","x","y","vertical","sliderHeight","itemHeight","sliderWidth","itemWidth","setState","Math","ceil","event","fadeDuration","onLoad","LOADED","timing","toValue","duration","easing","Easing","out","quad","isInteraction","useNativeDriver","start","TRANSITION_FINISHED","onError","ERROR","containerStyle","View","ref","c","pointerEvents","style","container","onLayout","image","spinner","scrollPosition","parallaxFactor","AnimatedImageComponent","other","parallaxPadding","requiredStyles","position","dynamicStyles","opacity","transform","translateX","interpolate","inputRange","outputRange","extrapolate","translateY","undefined","showSpinner","spinnerColor","loaderContainer","ActivityIndicator","size","color","animating","Image"],"sources":["ParallaxImage.tsx"],"sourcesContent":["// Parallax effect inspired by https://github.com/oblador/react-native-parallax/\n\nimport React, { Component } from 'react';\nimport {\n    View,\n    Animated,\n    Easing,\n    ActivityIndicator,\n    findNodeHandle,\n    ImageProps,\n    StyleProp,\n    ViewStyle,\n    NativeSyntheticEvent,\n    ImageLoadEventData,\n    ImageErrorEventData\n} from 'react-native';\nimport styles from './ParallaxImage.style';\n\ntype VerticalProps = {\n    vertical: true;\n    sliderHeight: number; // passed from <Carousel />\n    itemHeight: number; // passed from <Carousel />\n}\ntype HorizontalProps = {\n    vertical: false;\n    sliderWidth: number; // passed from <Carousel />\n    itemWidth: number; // passed from <Carousel />\n}\n\ntype ParallaxImageProps = {\n  carouselRef: Parameters<typeof findNodeHandle>[0]; // passed from <Carousel />\n  scrollPosition: Animated.Value | undefined; // passed from <Carousel />\n  containerStyle: StyleProp<ViewStyle>;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n  fadeDuration: number;\n  parallaxFactor: number;\n  showSpinner: boolean;\n  spinnerColor: string;\n  AnimatedImageComponent: typeof Animated.Image;\n} & ImageProps & (VerticalProps | HorizontalProps);\n\nexport enum ParallaxImageStatus {\n    'LOADING' = 1,\n    'LOADED' = 2,\n    'TRANSITION_FINISHED' = 3,\n    'ERROR' = 4\n}\n\ntype ParallaxImageState = {\n  offset: number;\n  width: number;\n  height: number;\n  status: ParallaxImageStatus;\n  animOpacity: Animated.Value;\n};\n\nexport default class ParallaxImage extends Component<\n  ParallaxImageProps,\n  ParallaxImageState\n> {\n  static defaultProps = {\n      containerStyle: {},\n      fadeDuration: 500,\n      parallaxFactor: 0.3,\n      showSpinner: true,\n      spinnerColor: 'rgba(0, 0, 0, 0.4)',\n      AnimatedImageComponent: Animated.Image\n  };\n\n  _container?: View | null;\n  _mounted?: boolean;\n\n  constructor (props: ParallaxImageProps) {\n      super(props);\n      this.state = {\n          offset: 0,\n          width: 0,\n          height: 0,\n          status: ParallaxImageStatus.LOADING,\n          animOpacity: new Animated.Value(0)\n      };\n      this._onLoad = this._onLoad.bind(this);\n      this._onError = this._onError.bind(this);\n      this._measureLayout = this._measureLayout.bind(this);\n  }\n\n  setNativeProps (nativeProps: { [key: string]: unknown }) {\n    this._container?.setNativeProps(nativeProps);\n  }\n\n  componentDidMount () {\n      this._mounted = true;\n\n      setTimeout(() => {\n          this._measureLayout();\n      }, 0);\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n  }\n\n  _measureLayout () {\n      if (this._container) {\n          const {\n              dimensions,\n              carouselRef\n          } = this.props;\n\n          const nodeHandle = findNodeHandle(carouselRef);\n\n          if (carouselRef && nodeHandle) {\n              this._container.measureLayout(\n                  nodeHandle,\n                  (x, y, width, height) => {\n                      const offset = this.props.vertical ?\n                          y - (this.props.sliderHeight - this.props.itemHeight) / 2 :\n                          x - (this.props.sliderWidth - this.props.itemWidth) / 2;\n\n                      this.setState({\n                          offset: offset,\n                          width:\n                dimensions && dimensions.width ?\n                    dimensions.width :\n                    Math.ceil(width),\n                          height:\n                dimensions && dimensions.height ?\n                    dimensions.height :\n                    Math.ceil(height)\n                      });\n                  },\n                  // eslint-disable-next-line @typescript-eslint/no-empty-function\n                  () => {}\n              );\n          }\n      }\n  }\n\n  _onLoad (event: NativeSyntheticEvent<ImageLoadEventData>) {\n      const { animOpacity } = this.state;\n      const { fadeDuration, onLoad } = this.props;\n\n      if (!this._mounted) {\n          return;\n      }\n\n      this.setState({ status: ParallaxImageStatus.LOADED });\n\n      if (onLoad) {\n          onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n          toValue: 1,\n          duration: fadeDuration,\n          easing: Easing.out(Easing.quad),\n          isInteraction: false,\n          useNativeDriver: true\n      }).start(() => {\n          this.setState({ status: ParallaxImageStatus.TRANSITION_FINISHED });\n      });\n  }\n\n  // If arg is missing from method signature, it just won't be called\n  _onError (event: NativeSyntheticEvent<ImageErrorEventData>) {\n      const { onError } = this.props;\n\n      this.setState({ status: ParallaxImageStatus.ERROR });\n\n      if (onError) {\n          onError(event);\n      }\n  }\n\n  get image () {\n      const { status, animOpacity, offset, width, height } = this.state;\n      const {\n          scrollPosition,\n          // False positive :( other doesn't have the dimension key\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          dimensions,\n          parallaxFactor,\n          style,\n          AnimatedImageComponent,\n          ...other\n      } = this.props;\n      const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      const requiredStyles = { position: 'relative' as const };\n      const dynamicStyles = {\n          width: this.props.vertical ? width : width + parallaxPadding * 2,\n          height: this.props.vertical ? height + parallaxPadding * 2 : height,\n          opacity: animOpacity,\n          transform: scrollPosition ?\n              [\n                  {\n                      translateX: !this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  },\n                  {\n                      translateY: this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  }\n              ] :\n              []\n      };\n\n      return (\n          <AnimatedImageComponent\n            {...other}\n            style={[styles.image, style, requiredStyles, dynamicStyles]}\n            onLoad={this._onLoad}\n            onError={status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined} // prevent infinite-loop bug\n          />\n      );\n  }\n\n  get spinner () {\n      const { status } = this.state;\n      const { showSpinner, spinnerColor } = this.props;\n\n      return status === ParallaxImageStatus.LOADING && showSpinner ? (\n          <View style={styles.loaderContainer}>\n              <ActivityIndicator\n                size='small'\n                color={spinnerColor}\n                animating={true}\n              />\n          </View>\n      ) : (\n          false\n      );\n  }\n\n  render () {\n      const { containerStyle } = this.props;\n\n      return (\n          <View\n            ref={(c) => {\n                this._container = c;\n            }}\n            pointerEvents='none'\n            style={[containerStyle, styles.container]}\n            onLayout={this._measureLayout}\n          >\n              {this.image}\n              {this.spinner}\n          </View>\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}