{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport findNodeHandleRN from \"react-native-web/dist/exports/findNodeHandle\";\nimport { handlerIDToTag } from \"./handlersRegistry\";\nimport { toArray } from \"../utils\";\nvar commonProps = ['id', 'enabled', 'shouldCancelWhenOutside', 'hitSlop'];\nvar componentInteractionProps = ['waitFor', 'simultaneousHandlers'];\nexport var baseGestureHandlerProps = [].concat(commonProps, componentInteractionProps, ['onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange']);\nexport var baseGestureHandlerWithMonitorProps = [].concat(commonProps, ['needsPointerData', 'manualActivation']);\n\nfunction isConfigParam(param, name) {\n  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n}\n\nexport function filterConfig(props, validProps) {\n  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var filteredConfig = _objectSpread({}, defaults);\n\n  for (var _iterator = validProps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _key = _ref;\n    var _value = props[_key];\n\n    if (isConfigParam(_value, _key)) {\n      if (_key === 'simultaneousHandlers' || _key === 'waitFor') {\n        _value = transformIntoHandlerTags(props[_key]);\n      } else if (_key === 'hitSlop' && typeof _value !== 'object') {\n        _value = {\n          top: _value,\n          left: _value,\n          bottom: _value,\n          right: _value\n        };\n      }\n\n      filteredConfig[_key] = _value;\n    }\n  }\n\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs.map(function (_ref2) {\n      var current = _ref2.current;\n      return current;\n    }).filter(function (handle) {\n      return handle;\n    });\n  }\n\n  return handlerIDs.map(function (handlerID) {\n    var _handlerID$current;\n\n    return handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;\n  }).filter(function (handlerTag) {\n    return handlerTag > 0;\n  });\n}\n\nexport function findNodeHandle(node) {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}","map":{"version":3,"sources":["gestureHandlerCommon.ts"],"names":["commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","param","Object","name","defaults","filteredConfig","value","props","isConfigParam","key","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","toArray","Platform","current","handle","handlerID","handlerIDToTag","handlerTag","findNodeHandleRN"],"mappings":"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","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\n\nimport { State } from '../State';\nimport { EventType } from '../EventType';\nimport { ValueOf } from '../typeUtils';\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\n\nconst commonProps = [\n  'id',\n  'enabled',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n] as const;\n\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\n\nexport const baseGestureHandlerProps = [\n  ...commonProps,\n  ...componentInteractionProps,\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport const baseGestureHandlerWithMonitorProps = [\n  ...commonProps,\n  'needsPointerData',\n  'manualActivation',\n];\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\nexport type HitSlop =\n  | number\n  | Partial<\n      Record<\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n        number\n      >\n    >\n  | Record<'width' | 'left', number>\n  | Record<'width' | 'right', number>\n  | Record<'height' | 'top', number>\n  | Record<'height' | 'bottom', number>;\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\nexport type TouchData = {\n  id: number;\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type GestureTouchEvent = {\n  handlerTag: number;\n  numberOfTouches: number;\n  state: ValueOf<typeof State>;\n  eventType: EventType;\n  allTouches: TouchData[];\n  changedTouches: TouchData[];\n};\n\nexport type GestureUpdateEvent<\n  GestureEventPayloadT = Record<string, unknown>\n> = GestureEventPayload & GestureEventPayloadT;\n\nexport type GestureStateChangeEvent<\n  GestureStateChangeEventPayloadT = Record<string, unknown>\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\n\nexport type CommonGestureConfig = {\n  enabled?: boolean;\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?: HitSlop;\n};\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = CommonGestureConfig & {\n  id?: string;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nexport function filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const filteredConfig = { ...defaults };\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = { top: value, left: value, bottom: value, right: value };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\nexport function findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n"]},"metadata":{},"sourceType":"module"}