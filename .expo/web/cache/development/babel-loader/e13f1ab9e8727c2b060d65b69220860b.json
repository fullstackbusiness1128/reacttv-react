{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport shallowCompare from 'react-addons-shallow-compare';\nimport { defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles, shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles } from \"../utils/animations\";\nvar IS_ANDROID = Platform.OS === 'android';\nvar IS_RTL = I18nManager.isRTL;\nexport var Carousel = function (_React$Component) {\n  _inherits(Carousel, _React$Component);\n\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Carousel).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"_activeItem\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollActiveItem\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_previousFirstItem\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_previousItemsLength\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_mounted\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_positions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_currentScrollOffset\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollEnabled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_initTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_apparitionTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_hackSlideAnimationTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_enableAutoplayTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_autoplayTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_snapNoMomentumTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_androidRepositioningTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_autoplayInterval\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_scrollPos\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_onScrollHandler\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_carouselRef\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_autoplaying\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_autoplay\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_onLayoutInitDone\", void 0);\n\n    _this.state = {\n      hideCarousel: !!props.apparitionDelay,\n      interpolators: []\n    };\n\n    var initialActiveItem = _this._getFirstItem(props.firstItem);\n\n    _this._activeItem = initialActiveItem;\n    _this._onScrollActiveItem = initialActiveItem;\n    _this._previousFirstItem = initialActiveItem;\n    _this._previousItemsLength = initialActiveItem;\n    _this._mounted = false;\n    _this._positions = [];\n    _this._currentScrollOffset = 0;\n    _this._scrollEnabled = props.scrollEnabled !== false;\n    _this._getCellRendererComponent = _this._getCellRendererComponent.bind(_assertThisInitialized(_this));\n    _this._getItemLayout = _this._getItemLayout.bind(_assertThisInitialized(_this));\n    _this._getKeyExtractor = _this._getKeyExtractor.bind(_assertThisInitialized(_this));\n    _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));\n    _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this));\n    _this._onMomentumScrollEnd = _this._onMomentumScrollEnd.bind(_assertThisInitialized(_this));\n    _this._onTouchStart = _this._onTouchStart.bind(_assertThisInitialized(_this));\n    _this._onTouchEnd = _this._onTouchEnd.bind(_assertThisInitialized(_this));\n    _this._renderItem = _this._renderItem.bind(_assertThisInitialized(_this));\n\n    _this._setScrollHandler(props);\n\n    _this._displayWarnings(props);\n\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          apparitionDelay = _this$props.apparitionDelay,\n          autoplay = _this$props.autoplay,\n          firstItem = _this$props.firstItem;\n      this._mounted = true;\n\n      this._initPositionsAndInterpolators();\n\n      this._initTimeout = setTimeout(function () {\n        if (!_this2._mounted) {\n          return;\n        }\n\n        var apparitionCallback = function apparitionCallback() {\n          if (apparitionDelay) {\n            _this2.setState({\n              hideCarousel: false\n            });\n          }\n\n          if (autoplay) {\n            _this2.startAutoplay();\n          }\n        };\n\n        if (_this2._needsScrollView()) {\n          var _firstItem = _this2._getFirstItem(firstItem);\n\n          _this2._snapToItem(_firstItem, false, false, true);\n        }\n\n        if (apparitionDelay) {\n          _this2._apparitionTimeout = setTimeout(function () {\n            apparitionCallback();\n          }, apparitionDelay);\n        } else {\n          apparitionCallback();\n        }\n      }, 1);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (this.props.shouldOptimizeUpdates === false) {\n        return true;\n      } else {\n        return shallowCompare(this, nextProps, nextState);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var interpolators = this.state.interpolators;\n      var _this$props2 = this.props,\n          firstItem = _this$props2.firstItem,\n          scrollEnabled = _this$props2.scrollEnabled;\n\n      var itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n        return;\n      }\n\n      var nextFirstItem = this._getFirstItem(firstItem, this.props);\n\n      var nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;\n      var hasNewSize = this.props.vertical !== prevProps.vertical || this.props.vertical && prevProps.vertical && (prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight) || !this.props.vertical && !prevProps.vertical && (prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth);\n\n      if (nextActiveItem > itemsLength - 1) {\n        nextActiveItem = itemsLength - 1;\n      }\n\n      if (scrollEnabled !== prevProps.scrollEnabled) {\n        this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (interpolators.length !== itemsLength || hasNewSize) {\n        this._activeItem = nextActiveItem;\n        this._previousItemsLength = itemsLength;\n\n        this._initPositionsAndInterpolators(this.props);\n\n        if (this._previousItemsLength > itemsLength) {\n          this._hackActiveSlideAnimation(nextActiveItem);\n        }\n\n        if (hasNewSize) {\n          this._snapToItem(nextActiveItem, false, false, true);\n        }\n      } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n        this._activeItem = nextFirstItem;\n        this._previousFirstItem = nextFirstItem;\n\n        this._snapToItem(nextFirstItem, false, true, true);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n        this._setScrollHandler(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n      this.stopAutoplay();\n      clearTimeout(this._initTimeout);\n      clearTimeout(this._apparitionTimeout);\n      clearTimeout(this._hackSlideAnimationTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._snapNoMomentumTimeout);\n      clearTimeout(this._androidRepositioningTimeout);\n    }\n  }, {\n    key: \"_setScrollHandler\",\n    value: function _setScrollHandler(props) {\n      var scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true\n      };\n      this._scrollPos = new Animated.Value(0);\n      var argMapping = props.vertical ? [{\n        nativeEvent: {\n          contentOffset: {\n            y: this._scrollPos\n          }\n        }\n      }] : [{\n        nativeEvent: {\n          contentOffset: {\n            x: this._scrollPos\n          }\n        }\n      }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        argMapping.pop();\n\n        var _props$onScroll$_argM = _slicedToArray(props.onScroll._argMapping, 1),\n            argMap = _props$onScroll$_argM[0];\n\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;\n        }\n\n        argMapping.push.apply(argMapping, _toConsumableArray(props.onScroll._argMapping));\n      }\n\n      this._onScrollHandler = Animated.event(argMapping, scrollEventConfig);\n    }\n  }, {\n    key: \"_displayWarnings\",\n    value: function _displayWarnings() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var pluginName = 'react-native-snap-carousel';\n      var removedProps = ['activeAnimationType', 'activeAnimationOptions', 'enableMomentum', 'lockScrollTimeoutDuration', 'lockScrollWhileSnapping', 'onBeforeSnapToItem', 'swipeThreshold'];\n\n      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n        console.error(\"\".concat(pluginName, \": You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels\"));\n      }\n\n      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n        console.error(\"\".concat(pluginName, \": You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels\"));\n      }\n\n      removedProps.forEach(function (removedProp) {\n        if (removedProp in props) {\n          console.warn(\"\".concat(pluginName, \": Prop \").concat(removedProp, \" has been removed in version 4 of the plugin\"));\n        }\n      });\n    }\n  }, {\n    key: \"_needsScrollView\",\n    value: function _needsScrollView() {\n      var useScrollView = this.props.useScrollView;\n      return IS_ANDROID ? useScrollView || !Animated.FlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() : useScrollView || !Animated.FlatList;\n    }\n  }, {\n    key: \"_needsRTLAdaptations\",\n    value: function _needsRTLAdaptations() {\n      var vertical = this.props.vertical;\n      return IS_RTL && IS_ANDROID && !vertical;\n    }\n  }, {\n    key: \"_enableLoop\",\n    value: function _enableLoop() {\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          enableSnap = _this$props3.enableSnap,\n          loop = _this$props3.loop;\n      return enableSnap && loop && data && data.length && data.length > 1;\n    }\n  }, {\n    key: \"_shouldAnimateSlides\",\n    value: function _shouldAnimateSlides() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var inactiveSlideOpacity = props.inactiveSlideOpacity,\n          inactiveSlideScale = props.inactiveSlideScale,\n          scrollInterpolator = props.scrollInterpolator,\n          slideInterpolatedStyle = props.slideInterpolatedStyle;\n      return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n  }, {\n    key: \"_shouldUseShiftLayout\",\n    value: function _shouldUseShiftLayout() {\n      var _this$props4 = this.props,\n          inactiveSlideShift = _this$props4.inactiveSlideShift,\n          layout = _this$props4.layout;\n      return layout === 'default' && inactiveSlideShift !== 0;\n    }\n  }, {\n    key: \"_shouldUseStackLayout\",\n    value: function _shouldUseStackLayout() {\n      return this.props.layout === 'stack';\n    }\n  }, {\n    key: \"_shouldUseTinderLayout\",\n    value: function _shouldUseTinderLayout() {\n      return this.props.layout === 'tinder';\n    }\n  }, {\n    key: \"_shouldRepositionScroll\",\n    value: function _shouldRepositionScroll(index) {\n      var _this$props5 = this.props,\n          data = _this$props5.data,\n          enableSnap = _this$props5.enableSnap,\n          loopClonesPerSide = _this$props5.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!enableSnap || !dataLength || !this._enableLoop() || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_roundNumber\",\n    value: function _roundNumber(num) {\n      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var rounder = Math.pow(10, decimals);\n      return Math.round((num + Number.EPSILON) * rounder) / rounder;\n    }\n  }, {\n    key: \"_isMultiple\",\n    value: function _isMultiple(x, y) {\n      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n    }\n  }, {\n    key: \"_getCustomData\",\n    value: function _getCustomData() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return [];\n      }\n\n      if (!this._enableLoop()) {\n        return data;\n      }\n\n      var previousItems = [];\n      var nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n        var _previousItems2, _nextItems2;\n\n        var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n        var remainder = loopClonesPerSide % dataLength;\n\n        for (var i = 0; i < dataMultiplier; i++) {\n          var _previousItems, _nextItems;\n\n          (_previousItems = previousItems).push.apply(_previousItems, _toConsumableArray(data));\n\n          (_nextItems = nextItems).push.apply(_nextItems, _toConsumableArray(data));\n        }\n\n        (_previousItems2 = previousItems).unshift.apply(_previousItems2, _toConsumableArray(data.slice(-remainder)));\n\n        (_nextItems2 = nextItems).push.apply(_nextItems2, _toConsumableArray(data.slice(0, remainder)));\n      } else {\n        previousItems = data.slice(-loopClonesPerSide);\n        nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n    }\n  }, {\n    key: \"_getCustomDataLength\",\n    value: function _getCustomDataLength() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n    }\n  }, {\n    key: \"_getCustomIndex\",\n    value: function _getCustomIndex(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || typeof index === 'undefined') {\n        return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n  }, {\n    key: \"_getDataIndex\",\n    value: function _getDataIndex(index) {\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          loopClonesPerSide = _this$props6.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n        return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n        return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n        if (loopClonesPerSide > dataLength) {\n          var baseDataIndexes = [];\n          var dataIndexes = [];\n          var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          var remainder = loopClonesPerSide % dataLength;\n\n          for (var i = 0; i < dataLength; i++) {\n            baseDataIndexes.push(i);\n          }\n\n          for (var j = 0; j < dataMultiplier; j++) {\n            dataIndexes.push.apply(dataIndexes, baseDataIndexes);\n          }\n\n          dataIndexes.unshift.apply(dataIndexes, _toConsumableArray(baseDataIndexes.slice(-remainder)));\n          return dataIndexes[index];\n        } else {\n          return index + dataLength - loopClonesPerSide;\n        }\n      } else {\n        return index - loopClonesPerSide;\n      }\n    }\n  }, {\n    key: \"_getPositionIndex\",\n    value: function _getPositionIndex(index) {\n      var _this$props7 = this.props,\n          loop = _this$props7.loop,\n          loopClonesPerSide = _this$props7.loopClonesPerSide;\n      return loop ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getSnapOffsets\",\n    value: function _getSnapOffsets() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      var offset = this._getItemMainDimension();\n\n      return _toConsumableArray(Array(this._getCustomDataLength(props))).map(function (_, i) {\n        return i * offset;\n      });\n    }\n  }, {\n    key: \"_getFirstItem\",\n    value: function _getFirstItem(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n      var loopClonesPerSide = props.loopClonesPerSide;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n        return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getWrappedRef\",\n    value: function _getWrappedRef() {\n      if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {\n        return this._carouselRef;\n      }\n\n      return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n  }, {\n    key: \"_getScrollEnabled\",\n    value: function _getScrollEnabled() {\n      return this._scrollEnabled;\n    }\n  }, {\n    key: \"_setScrollEnabled\",\n    value: function _setScrollEnabled() {\n      var scrollEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n        return;\n      }\n\n      wrappedRef.setNativeProps({\n        scrollEnabled: scrollEnabled\n      });\n      this._scrollEnabled = scrollEnabled;\n    }\n  }, {\n    key: \"_getItemMainDimension\",\n    value: function _getItemMainDimension() {\n      return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;\n    }\n  }, {\n    key: \"_getItemScrollOffset\",\n    value: function _getItemScrollOffset(index) {\n      return this._positions && this._positions[index] && this._positions[index].start;\n    }\n  }, {\n    key: \"_getItemLayout\",\n    value: function _getItemLayout(_, index) {\n      var itemMainDimension = this._getItemMainDimension();\n\n      return {\n        index: index,\n        length: itemMainDimension,\n        offset: itemMainDimension * index\n      };\n    }\n  }, {\n    key: \"_getCellRendererComponent\",\n    value: function _getCellRendererComponent(_ref) {\n      var children = _ref.children,\n          index = _ref.index,\n          style = _ref.style,\n          props = _objectWithoutProperties(_ref, [\"children\", \"index\", \"style\"]);\n\n      var cellStyle = [style, !IS_ANDROID ? {\n        zIndex: this._getCustomDataLength() - index\n      } : {}];\n      return React.createElement(View, _extends({\n        style: cellStyle,\n        key: index\n      }, props), children);\n    }\n  }, {\n    key: \"_getKeyExtractor\",\n    value: function _getKeyExtractor(_, index) {\n      return this._needsScrollView() ? \"scrollview-item-\".concat(index) : \"flatlist-item-\".concat(index);\n    }\n  }, {\n    key: \"_getScrollOffset\",\n    value: function _getScrollOffset(event) {\n      var vertical = this.props.vertical;\n      return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;\n    }\n  }, {\n    key: \"_getContainerInnerMargin\",\n    value: function _getContainerInnerMargin() {\n      var opposite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var activeSlideAlignment = this.props.activeSlideAlignment;\n\n      if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {\n        return 0;\n      } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {\n        return this.props.vertical ? this.props.sliderHeight - this.props.itemHeight : this.props.sliderWidth - this.props.itemWidth;\n      } else {\n        return this.props.vertical ? (this.props.sliderHeight - this.props.itemHeight) / 2 : (this.props.sliderWidth - this.props.itemWidth) / 2;\n      }\n    }\n  }, {\n    key: \"_getActiveSlideOffset\",\n    value: function _getActiveSlideOffset() {\n      var activeSlideOffset = this.props.activeSlideOffset;\n\n      var itemMainDimension = this._getItemMainDimension();\n\n      var minOffset = 10;\n      return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;\n    }\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem(offset) {\n      var itemMainDimension = this._getItemMainDimension();\n\n      var center = offset + itemMainDimension / 2;\n\n      var activeSlideOffset = this._getActiveSlideOffset();\n\n      var lastIndex = this._positions.length - 1;\n      var itemIndex;\n\n      if (offset <= 0) {\n        return 0;\n      }\n\n      if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {\n        return lastIndex;\n      }\n\n      for (var i = 0; i < this._positions.length; i++) {\n        var _this$_positions$i = this._positions[i],\n            start = _this$_positions$i.start,\n            end = _this$_positions$i.end;\n\n        if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex || 0;\n    }\n  }, {\n    key: \"_getSlideInterpolatedStyle\",\n    value: function _getSlideInterpolatedStyle(index, animatedValue) {\n      var _this$props8 = this.props,\n          layoutCardOffset = _this$props8.layoutCardOffset,\n          slideInterpolatedStyle = _this$props8.slideInterpolatedStyle;\n\n      if (slideInterpolatedStyle) {\n        return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n        return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseStackLayout()) {\n        return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseShiftLayout()) {\n        return shiftAnimatedStyles(index, animatedValue, this.props);\n      } else {\n        return defaultAnimatedStyles(index, animatedValue, this.props);\n      }\n    }\n  }, {\n    key: \"_initPositionsAndInterpolators\",\n    value: function _initPositionsAndInterpolators() {\n      var _this3 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          scrollInterpolator = props.scrollInterpolator;\n\n      var itemMainDimension = this._getItemMainDimension();\n\n      if (!data || !data.length) {\n        return;\n      }\n\n      var interpolators = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach(function (_itemData, index) {\n        var _index = _this3._getCustomIndex(index, props);\n\n        var animatedValue;\n        _this3._positions[index] = {\n          start: index * itemMainDimension,\n          end: index * itemMainDimension + itemMainDimension\n        };\n\n        if (!_this3._shouldAnimateSlides(props) || !_this3._scrollPos) {\n          animatedValue = new Animated.Value(1);\n        } else {\n          var interpolator;\n\n          if (scrollInterpolator) {\n            interpolator = scrollInterpolator(_index, props);\n          } else if (_this3._shouldUseStackLayout()) {\n            interpolator = stackScrollInterpolator(_index, props);\n          } else if (_this3._shouldUseTinderLayout()) {\n            interpolator = tinderScrollInterpolator(_index, props);\n          }\n\n          if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n            interpolator = defaultScrollInterpolator(_index, props);\n          }\n\n          animatedValue = _this3._scrollPos.interpolate(_objectSpread({}, interpolator, {\n            extrapolate: 'clamp'\n          }));\n        }\n\n        interpolators.push(animatedValue);\n      });\n\n      this.setState({\n        interpolators: interpolators\n      });\n    }\n  }, {\n    key: \"_hackActiveSlideAnimation\",\n    value: function _hackActiveSlideAnimation(index) {\n      var _this4 = this;\n\n      var scrollValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var offset = this._getItemScrollOffset(index);\n\n      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n        return;\n      }\n\n      var multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n      var scrollDelta = scrollValue * multiplier;\n\n      this._scrollTo({\n        offset: offset + scrollDelta,\n        animated: false\n      });\n\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(function () {\n        _this4._scrollTo({\n          offset: offset,\n          animated: false\n        });\n      }, 1);\n    }\n  }, {\n    key: \"_repositionScroll\",\n    value: function _repositionScroll(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$props9 = this.props,\n          data = _this$props9.data,\n          loopClonesPerSide = _this$props9.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n        return;\n      }\n\n      var repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n        repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n        repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, animated, false);\n    }\n  }, {\n    key: \"_scrollTo\",\n    value: function _scrollTo(_ref2) {\n      var offset = _ref2.offset,\n          index = _ref2.index,\n          _ref2$animated = _ref2.animated,\n          animated = _ref2$animated === void 0 ? true : _ref2$animated;\n      var vertical = this.props.vertical;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!this._mounted || !wrappedRef || typeof offset === 'undefined' && typeof index === 'undefined') {\n        return;\n      }\n\n      var scrollToOffset;\n\n      if (typeof index !== 'undefined') {\n        scrollToOffset = this._getItemScrollOffset(index);\n      } else {\n        scrollToOffset = offset;\n      }\n\n      if (typeof scrollToOffset === 'undefined') {\n        return;\n      }\n\n      var options = this._needsScrollView() ? {\n        x: vertical ? 0 : offset,\n        y: vertical ? offset : 0,\n        animated: animated\n      } : {\n        offset: offset,\n        animated: animated\n      };\n\n      if (this._needsScrollView()) {\n        wrappedRef.scrollTo(options);\n      } else {\n        wrappedRef.scrollToOffset(options);\n      }\n    }\n  }, {\n    key: \"_onTouchStart\",\n    value: function _onTouchStart(event) {\n      var onTouchStart = this.props.onTouchStart;\n\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n        this.pauseAutoPlay();\n      }\n\n      onTouchStart && onTouchStart(event);\n    }\n  }, {\n    key: \"_onTouchEnd\",\n    value: function _onTouchEnd(event) {\n      var onTouchEnd = this.props.onTouchEnd;\n\n      if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n        this.startAutoplay();\n      }\n\n      onTouchEnd && onTouchEnd(event);\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      var _this$props10 = this.props,\n          onScroll = _this$props10.onScroll,\n          onScrollIndexChanged = _this$props10.onScrollIndexChanged;\n      var scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n\n      var nextActiveItem = this._getActiveItem(scrollOffset);\n\n      this._currentScrollOffset = scrollOffset;\n\n      if (nextActiveItem !== this._onScrollActiveItem) {\n        this._onScrollActiveItem = nextActiveItem;\n        onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n      }\n\n      if (typeof onScroll === 'function' && event) {\n        onScroll(event);\n      }\n    }\n  }, {\n    key: \"_onMomentumScrollEnd\",\n    value: function _onMomentumScrollEnd(event) {\n      var _this5 = this;\n\n      var _this$props11 = this.props,\n          autoplayDelay = _this$props11.autoplayDelay,\n          onMomentumScrollEnd = _this$props11.onMomentumScrollEnd,\n          onSnapToItem = _this$props11.onSnapToItem;\n      var scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n\n      var nextActiveItem = this._getActiveItem(scrollOffset);\n\n      var hasSnapped = this._isMultiple(scrollOffset, this.props.vertical ? this.props.itemHeight : this.props.itemWidth);\n\n      if (nextActiveItem !== this._activeItem) {\n        this._activeItem = nextActiveItem;\n        onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n        if (hasSnapped) {\n          this._repositionScroll(nextActiveItem);\n        }\n      }\n\n      onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n      if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n        clearTimeout(this._enableAutoplayTimeout);\n        this._enableAutoplayTimeout = setTimeout(function () {\n          _this5.startAutoplay();\n        }, autoplayDelay);\n      }\n    }\n  }, {\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var onLayout = this.props.onLayout;\n\n      if (this._onLayoutInitDone) {\n        this._initPositionsAndInterpolators();\n\n        this._snapToItem(this._activeItem, false, false, true);\n      } else {\n        this._onLayoutInitDone = true;\n      }\n\n      onLayout && onLayout(event);\n    }\n  }, {\n    key: \"_snapToItem\",\n    value: function _snapToItem(index) {\n      var _this6 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var forceScrollTo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var onSnapToItem = this.props.onSnapToItem;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n        return;\n      }\n\n      if (!index || index < 0) {\n        index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n        index = itemsLength - 1;\n      }\n\n      if (index === this._activeItem && !forceScrollTo) {\n        return;\n      }\n\n      var offset = this._getItemScrollOffset(index);\n\n      if (offset === undefined) {\n        return;\n      }\n\n      this._scrollTo({\n        offset: offset,\n        animated: animated\n      });\n\n      var requiresManualTrigger = !animated || IS_ANDROID;\n\n      if (requiresManualTrigger) {\n        this._activeItem = index;\n\n        if (fireCallback) {\n          onSnapToItem && onSnapToItem(this._getDataIndex(index));\n        }\n\n        if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n          if (animated) {\n            this._androidRepositioningTimeout = setTimeout(function () {\n              _this6._repositionScroll(index, true);\n            }, 400);\n          } else {\n            this._repositionScroll(index);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this7 = this;\n\n      var _this$props12 = this.props,\n          autoplayInterval = _this$props12.autoplayInterval,\n          autoplayDelay = _this$props12.autoplayDelay;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n        return;\n      }\n\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(function () {\n        _this7._autoplaying = true;\n        _this7._autoplayInterval = setInterval(function () {\n          if (_this7._autoplaying) {\n            _this7.snapToNext();\n          }\n        }, autoplayInterval);\n      }, autoplayDelay);\n    }\n  }, {\n    key: \"pauseAutoPlay\",\n    value: function pauseAutoPlay() {\n      this._autoplaying = false;\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearInterval(this._autoplayInterval);\n    }\n  }, {\n    key: \"stopAutoplay\",\n    value: function stopAutoplay() {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n    }\n  }, {\n    key: \"snapToItem\",\n    value: function snapToItem(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (!index || index < 0) {\n        index = 0;\n      }\n\n      var positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n        return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToNext\",\n    value: function snapToNext() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem + 1;\n\n      if (newIndex > itemsLength - 1) {\n        newIndex = 0;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToPrev\",\n    value: function snapToPrev() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem - 1;\n\n      if (newIndex < 0) {\n        newIndex = itemsLength - 1;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"triggerRenderingHack\",\n    value: function triggerRenderingHack() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      this._hackActiveSlideAnimation(this._activeItem, offset);\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(_ref3) {\n      var item = _ref3.item,\n          index = _ref3.index;\n      var interpolators = this.state.interpolators;\n      var _this$props13 = this.props,\n          keyExtractor = _this$props13.keyExtractor,\n          slideStyle = _this$props13.slideStyle;\n      var animatedValue = interpolators && interpolators[index];\n\n      if (typeof animatedValue === 'undefined') {\n        return null;\n      }\n\n      var animate = this._shouldAnimateSlides();\n\n      var Component = animate ? Animated.View : View;\n      var animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n      var dataIndex = this._getDataIndex(index);\n\n      var mainDimension = this.props.vertical ? {\n        height: this.props.itemHeight\n      } : {\n        width: this.props.itemWidth\n      };\n      var specificProps = this._needsScrollView() ? {\n        key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n      } : {};\n      return React.createElement(Component, _extends({\n        style: [mainDimension, slideStyle, animatedStyle],\n        pointerEvents: \"box-none\"\n      }, specificProps), this.props.vertical ? this.props.renderItem({\n        item: item,\n        index: index,\n        dataIndex: dataIndex\n      }, {\n        scrollPosition: this._scrollPos,\n        carouselRef: this._carouselRef,\n        vertical: this.props.vertical,\n        sliderHeight: this.props.sliderHeight,\n        itemHeight: this.props.itemHeight\n      }) : this.props.renderItem({\n        item: item,\n        index: index,\n        dataIndex: dataIndex\n      }, {\n        scrollPosition: this._scrollPos,\n        carouselRef: this._carouselRef,\n        vertical: !!this.props.vertical,\n        sliderWidth: this.props.sliderWidth,\n        itemWidth: this.props.itemWidth\n      }));\n    }\n  }, {\n    key: \"_getComponentOverridableProps\",\n    value: function _getComponentOverridableProps() {\n      var hideCarousel = this.state.hideCarousel;\n      var loopClonesPerSide = this.props.loopClonesPerSide;\n      var visibleItems = Math.ceil(this.props.vertical ? this.props.sliderHeight / this.props.itemHeight : this.props.sliderWidth / this.props.itemWidth) + 1;\n      var initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      var initialNumToRender = visibleItems + initialNumPerSide * 2;\n      var maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;\n      var windowSize = maxToRenderPerBatch;\n      var specificProps = !this._needsScrollView() ? {\n        initialNumToRender: initialNumToRender,\n        maxToRenderPerBatch: maxToRenderPerBatch,\n        windowSize: windowSize\n      } : {};\n      return _objectSpread({}, specificProps, {\n        automaticallyAdjustContentInsets: false,\n        decelerationRate: 'fast',\n        directionalLockEnabled: true,\n        disableScrollViewPanResponder: false,\n        inverted: this._needsRTLAdaptations(),\n        overScrollMode: 'never',\n        pinchGestureEnabled: false,\n        pointerEvents: hideCarousel ? 'none' : 'auto',\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        showsVerticalScrollIndicator: false\n      });\n    }\n  }, {\n    key: \"_getComponentStaticProps\",\n    value: function _getComponentStaticProps() {\n      var _this8 = this;\n\n      var hideCarousel = this.state.hideCarousel;\n      var _this$props14 = this.props,\n          activeSlideAlignment = _this$props14.activeSlideAlignment,\n          CellRendererComponent = _this$props14.CellRendererComponent,\n          containerCustomStyle = _this$props14.containerCustomStyle,\n          contentContainerCustomStyle = _this$props14.contentContainerCustomStyle,\n          firstItem = _this$props14.firstItem,\n          getItemLayout = _this$props14.getItemLayout,\n          keyExtractor = _this$props14.keyExtractor,\n          style = _this$props14.style,\n          useExperimentalSnap = _this$props14.useExperimentalSnap;\n      var containerStyle = [containerCustomStyle || style || {}, hideCarousel ? {\n        opacity: 0\n      } : {}, this.props.vertical ? {\n        height: this.props.sliderHeight,\n        flexDirection: 'column'\n      } : {\n        width: this.props.sliderWidth,\n        flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'\n      }];\n      var innerMarginStyle = this.props.vertical ? {\n        paddingTop: this._getContainerInnerMargin(),\n        paddingBottom: this._getContainerInnerMargin(true)\n      } : {\n        paddingLeft: this._getContainerInnerMargin(),\n        paddingRight: this._getContainerInnerMargin(true)\n      };\n      var contentContainerStyle = [!useExperimentalSnap ? innerMarginStyle : {}, contentContainerCustomStyle || {}];\n      var snapProps = useExperimentalSnap ? {\n        snapToAlignment: activeSlideAlignment,\n        snapToInterval: this._getItemMainDimension()\n      } : {\n        snapToOffsets: this._getSnapOffsets()\n      };\n      var specificProps = !this._needsScrollView() ? {\n        CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,\n        getItemLayout: getItemLayout || this._getItemLayout,\n        initialScrollIndex: this._getFirstItem(firstItem),\n        keyExtractor: keyExtractor || this._getKeyExtractor,\n        numColumns: 1,\n        renderItem: this._renderItem\n      } : {};\n      return _objectSpread({}, specificProps, {}, snapProps, {\n        ref: function ref(c) {\n          _this8._carouselRef = c;\n        },\n        contentContainerStyle: contentContainerStyle,\n        data: this._getCustomData(),\n        horizontal: !this.props.vertical,\n        scrollEventThrottle: 1,\n        style: containerStyle,\n        onLayout: this._onLayout,\n        onMomentumScrollEnd: this._onMomentumScrollEnd,\n        onScroll: this._onScrollHandler,\n        onTouchStart: this._onTouchStart,\n        onTouchEnd: this._onTouchEnd\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n\n      var _this$props15 = this.props,\n          data = _this$props15.data,\n          renderItem = _this$props15.renderItem,\n          useScrollView = _this$props15.useScrollView;\n\n      if (!data || !renderItem) {\n        return null;\n      }\n\n      var props = _objectSpread({}, this._getComponentOverridableProps(), {}, this.props, {}, this._getComponentStaticProps());\n\n      var ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;\n      return this._needsScrollView() || !Animated.FlatList ? React.createElement(ScrollViewComponent, props, this._getCustomData().map(function (item, index) {\n        return _this9._renderItem({\n          item: item,\n          index: index\n        });\n      })) : React.createElement(Animated.FlatList, props);\n    }\n  }, {\n    key: \"realIndex\",\n    get: function get() {\n      return this._activeItem;\n    }\n  }, {\n    key: \"currentIndex\",\n    get: function get() {\n      return this._getDataIndex(this._activeItem);\n    }\n  }, {\n    key: \"currentScrollPosition\",\n    get: function get() {\n      return this._currentScrollOffset;\n    }\n  }]);\n\n  return Carousel;\n}(React.Component);\n\n_defineProperty(Carousel, \"defaultProps\", {\n  activeSlideAlignment: 'center',\n  activeSlideOffset: 20,\n  apparitionDelay: 0,\n  autoplay: false,\n  autoplayDelay: 1000,\n  autoplayInterval: 3000,\n  callbackOffsetMargin: 5,\n  containerCustomStyle: {},\n  contentContainerCustomStyle: {},\n  enableSnap: true,\n  firstItem: 0,\n  hasParallaxImages: false,\n  inactiveSlideOpacity: 0.7,\n  inactiveSlideScale: 0.9,\n  inactiveSlideShift: 0,\n  layout: 'default',\n  loop: false,\n  loopClonesPerSide: 3,\n  scrollEnabled: true,\n  slideStyle: {},\n  shouldOptimizeUpdates: true,\n  useExperimentalSnap: false,\n  useScrollView: !Animated.FlatList\n});\n\nexport default Carousel;","map":{"version":3,"sources":["Carousel.tsx"],"names":["IS_ANDROID","Platform","IS_RTL","I18nManager","Carousel","React","activeSlideAlignment","activeSlideOffset","apparitionDelay","autoplay","autoplayDelay","autoplayInterval","callbackOffsetMargin","containerCustomStyle","contentContainerCustomStyle","enableSnap","firstItem","hasParallaxImages","inactiveSlideOpacity","inactiveSlideScale","inactiveSlideShift","layout","loop","loopClonesPerSide","scrollEnabled","slideStyle","shouldOptimizeUpdates","useExperimentalSnap","useScrollView","Animated","FlatList","constructor","hideCarousel","props","interpolators","initialActiveItem","setTimeout","apparitionCallback","_firstItem","shallowCompare","itemsLength","nextFirstItem","nextActiveItem","hasNewSize","prevProps","clearTimeout","scrollEventConfig","listener","useNativeDriver","argMapping","nativeEvent","contentOffset","y","_scrollPos","x","Array","argMap","pluginName","removedProps","console","removedProp","vertical","data","slideInterpolatedStyle","dataLength","index","decimals","rounder","Math","num","Number","previousItems","nextItems","dataMultiplier","remainder","i","baseDataIndexes","dataIndexes","j","offset","wrappedRef","itemMainDimension","length","cellStyle","zIndex","event","opposite","minOffset","center","lastIndex","end","itemIndex","tinderAnimatedStyles","stackAnimatedStyles","shiftAnimatedStyles","defaultAnimatedStyles","scrollInterpolator","_index","start","animatedValue","interpolator","stackScrollInterpolator","tinderScrollInterpolator","defaultScrollInterpolator","extrapolate","scrollValue","multiplier","scrollDelta","animated","repositionTo","scrollToOffset","options","onTouchStart","onTouchEnd","onScrollIndexChanged","scrollOffset","onScroll","onSnapToItem","hasSnapped","onMomentumScrollEnd","onLayout","fireCallback","forceScrollTo","requiresManualTrigger","setInterval","clearInterval","positionIndex","newIndex","animate","Component","animatedStyle","dataIndex","mainDimension","height","itemHeight","width","itemWidth","specificProps","key","keyExtractor","item","scrollPosition","carouselRef","sliderHeight","sliderWidth","visibleItems","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","automaticallyAdjustContentInsets","decelerationRate","directionalLockEnabled","disableScrollViewPanResponder","inverted","overScrollMode","pinchGestureEnabled","pointerEvents","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","containerStyle","opacity","flexDirection","innerMarginStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","contentContainerStyle","snapProps","snapToAlignment","snapToInterval","snapToOffsets","CellRendererComponent","getItemLayout","initialScrollIndex","numColumns","renderItem","_renderItem","ref","c","horizontal","scrollEventThrottle","style","_onTouchEnd","ScrollViewComponent"],"mappings":"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","sourcesContent":["import React, { PropsWithChildren } from 'react';\nimport {\n    Animated,\n    FlatList,\n    I18nManager,\n    Platform,\n    ScrollView,\n    View,\n    StyleProp,\n    NativeSyntheticEvent,\n    NativeScrollEvent,\n    LayoutChangeEvent,\n    GestureResponderEvent,\n    ViewStyle\n} from 'react-native';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\nimport type { CarouselProps, CarouselState } from './types';\n\n// Metro doesn't support dynamic imports - i.e. require() done in the component itself\n// But at the same time the following import will fail on Snack...\n// TODO: find a way to get React Native's version without having to assume the file path\n// import RN_PACKAGE from '../../../react-native/package.json';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport class Carousel<TData> extends React.Component<\n  CarouselProps<TData>,\n  CarouselState\n> {\n  static defaultProps = {\n      activeSlideAlignment: 'center',\n      activeSlideOffset: 20,\n      apparitionDelay: 0,\n      autoplay: false,\n      autoplayDelay: 1000,\n      autoplayInterval: 3000,\n      callbackOffsetMargin: 5,\n      containerCustomStyle: {},\n      contentContainerCustomStyle: {},\n      enableSnap: true,\n      firstItem: 0,\n      hasParallaxImages: false,\n      inactiveSlideOpacity: 0.7,\n      inactiveSlideScale: 0.9,\n      inactiveSlideShift: 0,\n      layout: 'default',\n      loop: false,\n      loopClonesPerSide: 3,\n      scrollEnabled: true,\n      slideStyle: {},\n      shouldOptimizeUpdates: true,\n      useExperimentalSnap: false,\n      useScrollView: !Animated.FlatList\n  };\n\n  _activeItem: number;\n  _onScrollActiveItem: number;\n  _previousFirstItem: number;\n  _previousItemsLength: number;\n  _mounted: boolean;\n  _positions: { start: number; end: number }[];\n  _currentScrollOffset: number;\n  _scrollEnabled: boolean;\n\n  _initTimeout?: ReturnType<typeof setTimeout>;\n  _apparitionTimeout?: ReturnType<typeof setTimeout>;\n  _hackSlideAnimationTimeout?: ReturnType<typeof setTimeout>;\n  _enableAutoplayTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayTimeout?: ReturnType<typeof setTimeout>;\n  _snapNoMomentumTimeout?: ReturnType<typeof setTimeout>;\n  _androidRepositioningTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayInterval?: ReturnType<typeof setInterval>;\n\n  _scrollPos?: Animated.Value;\n\n  _onScrollHandler?: ReturnType<typeof Animated.event>;\n\n  _carouselRef: ScrollView | FlatList<TData> | null = null;\n\n  _autoplaying?: boolean;\n  _autoplay?: boolean;\n\n  _onLayoutInitDone?: boolean;\n\n  constructor (props: CarouselProps<TData>) {\n      super(props);\n\n      this.state = {\n          hideCarousel: !!props.apparitionDelay,\n          interpolators: []\n      };\n\n      // this._RNVersionCode = this._getRNVersionCode();\n\n      // The following values are not stored in the state because 'setState()' is asynchronous\n      // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n      const initialActiveItem = this._getFirstItem(props.firstItem);\n      this._activeItem = initialActiveItem;\n      this._onScrollActiveItem = initialActiveItem;\n      this._previousFirstItem = initialActiveItem;\n      this._previousItemsLength = initialActiveItem;\n\n      this._mounted = false;\n      this._positions = [];\n      this._currentScrollOffset = 0; // Store ScrollView's scroll position\n      this._scrollEnabled = props.scrollEnabled !== false;\n\n      this._getCellRendererComponent = this._getCellRendererComponent.bind(this);\n      this._getItemLayout = this._getItemLayout.bind(this);\n      this._getKeyExtractor = this._getKeyExtractor.bind(this);\n      this._onLayout = this._onLayout.bind(this);\n      this._onScroll = this._onScroll.bind(this);\n      this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);\n      this._onTouchStart = this._onTouchStart.bind(this);\n      this._onTouchEnd = this._onTouchEnd.bind(this);\n      this._renderItem = this._renderItem.bind(this);\n\n      // WARNING: call this AFTER binding _onScroll\n      this._setScrollHandler(props);\n\n      // Display warnings\n      this._displayWarnings(props);\n  }\n\n  componentDidMount () {\n      const { apparitionDelay, autoplay, firstItem } = this.props;\n\n      this._mounted = true;\n      this._initPositionsAndInterpolators();\n\n      // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n      this._initTimeout = setTimeout(() => {\n          if (!this._mounted) {\n              return;\n          }\n\n          const apparitionCallback = () => {\n              if (apparitionDelay) {\n                  this.setState({ hideCarousel: false });\n              }\n              if (autoplay) {\n                  this.startAutoplay();\n              }\n          };\n\n          // FlatList will use its own built-in prop `initialScrollIndex`\n          if (this._needsScrollView()) {\n              const _firstItem = this._getFirstItem(firstItem);\n              this._snapToItem(_firstItem, false, false, true);\n              // this._hackActiveSlideAnimation(_firstItem);\n          }\n\n          if (apparitionDelay) {\n              this._apparitionTimeout = setTimeout(() => {\n                  apparitionCallback();\n              }, apparitionDelay);\n          } else {\n              apparitionCallback();\n          }\n      }, 1);\n  }\n\n  shouldComponentUpdate (\n      nextProps: CarouselProps<TData>,\n      nextState: CarouselState\n  ): boolean {\n      if (this.props.shouldOptimizeUpdates === false) {\n          return true;\n      } else {\n          return shallowCompare(this, nextProps, nextState);\n      }\n  }\n\n  componentDidUpdate (prevProps: CarouselProps<TData>) {\n      const { interpolators } = this.state;\n      const {\n          firstItem,\n          scrollEnabled\n      } = this.props;\n      const itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n          return;\n      }\n\n      const nextFirstItem = this._getFirstItem(firstItem, this.props);\n      let nextActiveItem =\n      typeof this._activeItem !== 'undefined' ?\n          this._activeItem :\n          nextFirstItem;\n\n      const hasNewSize = this.props.vertical !== prevProps.vertical ||\n       (\n           this.props.vertical && prevProps.vertical && (\n               prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight\n           )\n       ) || (\n          !this.props.vertical && !prevProps.vertical && (\n              prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth\n          )\n      );\n\n      // Prevent issues with dynamically removed items\n      if (nextActiveItem > itemsLength - 1) {\n          nextActiveItem = itemsLength - 1;\n      }\n\n      // Handle changing scrollEnabled independent of user -> carousel interaction\n      if (scrollEnabled !== prevProps.scrollEnabled) {\n          this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (\n          interpolators.length !== itemsLength ||\n          hasNewSize\n      ) {\n          this._activeItem = nextActiveItem;\n          this._previousItemsLength = itemsLength;\n\n          this._initPositionsAndInterpolators(this.props);\n\n          // Handle scroll issue when dynamically removing items (see #133)\n          // This also fixes first item's active state on Android\n          // Because 'initialScrollIndex' apparently doesn't trigger scroll\n          if (this._previousItemsLength > itemsLength) {\n              this._hackActiveSlideAnimation(nextActiveItem);\n          }\n\n          if (hasNewSize) {\n              this._snapToItem(nextActiveItem, false, false, true);\n          }\n      } else if (\n          nextFirstItem !== this._previousFirstItem &&\n      nextFirstItem !== this._activeItem\n      ) {\n          this._activeItem = nextFirstItem;\n          this._previousFirstItem = nextFirstItem;\n          this._snapToItem(nextFirstItem, false, true, true);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n      }\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n      this.stopAutoplay();\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._initTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._apparitionTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._snapNoMomentumTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._androidRepositioningTimeout);\n  }\n\n  get realIndex () {\n      return this._activeItem;\n  }\n\n  get currentIndex () {\n      return this._getDataIndex(this._activeItem);\n  }\n\n  get currentScrollPosition () {\n      return this._currentScrollOffset;\n  }\n\n  _setScrollHandler (props: CarouselProps<TData>) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n          listener: this._onScroll,\n          useNativeDriver: true\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical ?\n          [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :\n          [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      // @ts-expect-error Let's ignore for now that trick\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n          argMapping.pop();\n          // @ts-expect-error Let's ignore for now that trick\n          const [argMap] = props.onScroll._argMapping;\n          if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n              // Shares the same animated value passed in props\n              this._scrollPos =\n          argMap.nativeEvent.contentOffset.x ||\n          argMap.nativeEvent.contentOffset.y ||\n          this._scrollPos;\n          }\n          // @ts-expect-error Let's ignore for now that trick\n          argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event<NativeScrollEvent>(\n          argMapping,\n          scrollEventConfig\n      );\n  }\n\n  // This will return a future-proof version code number compatible with semantic versioning\n  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002\n  // _getRNVersionCode () {\n  //     const version = RN_PACKAGE && RN_PACKAGE.version;\n  //     if (!version) {\n  //         return null;\n  //     }\n  //     const versionSplit = version.split('.');\n  //     if (!versionSplit || !versionSplit.length) {\n  //         return null;\n  //     }\n  //     return versionSplit[0] * 10000 +\n  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +\n  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);\n  // }\n\n  _displayWarnings (props: CarouselProps<TData> = this.props) {\n      const pluginName = 'react-native-snap-carousel';\n      const removedProps = [\n          'activeAnimationType',\n          'activeAnimationOptions',\n          'enableMomentum',\n          'lockScrollTimeoutDuration',\n          'lockScrollWhileSnapping',\n          'onBeforeSnapToItem',\n          'swipeThreshold'\n      ] as const;\n\n      // if (this._RNVersionCode && this._RNVersionCode < 5800) {\n      //     console.error(\n      //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +\n      //         'Please downgrade to version 3.x or update your version of React Native.'\n      //     );\n      // }\n      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`\n          );\n      }\n      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`\n          );\n      }\n\n      removedProps.forEach((removedProp) => {\n          if (removedProp in props) {\n              console.warn(\n                  `${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`\n              );\n          }\n      });\n  }\n\n  _needsScrollView () {\n      const { useScrollView } = this.props;\n      // Android's cell renderer is buggy and has a stange overflow\n      // TODO: a workaround might be to pass the custom animated styles directly to it\n      return IS_ANDROID ?\n          useScrollView ||\n          !Animated.FlatList ||\n          this._shouldUseStackLayout() ||\n          this._shouldUseTinderLayout() :\n          useScrollView || !Animated.FlatList;\n  }\n\n  _needsRTLAdaptations () {\n      const { vertical } = this.props;\n      return IS_RTL && IS_ANDROID && !vertical;\n  }\n\n  _enableLoop () {\n      const { data, enableSnap, loop } = this.props;\n      return enableSnap && loop && data && data.length && data.length > 1;\n  }\n\n  _shouldAnimateSlides (props: CarouselProps<TData> = this.props) {\n      const {\n          inactiveSlideOpacity,\n          inactiveSlideScale,\n          scrollInterpolator,\n          slideInterpolatedStyle\n      } = props;\n      return (\n          inactiveSlideOpacity < 1 ||\n      inactiveSlideScale < 1 ||\n      !!scrollInterpolator ||\n      !!slideInterpolatedStyle ||\n      this._shouldUseShiftLayout() ||\n      this._shouldUseStackLayout() ||\n      this._shouldUseTinderLayout()\n      );\n  }\n\n  _shouldUseShiftLayout () {\n      const { inactiveSlideShift, layout } = this.props;\n      return layout === 'default' && inactiveSlideShift !== 0;\n  }\n\n  _shouldUseStackLayout () {\n      return this.props.layout === 'stack';\n  }\n\n  _shouldUseTinderLayout () {\n      return this.props.layout === 'tinder';\n  }\n\n  _shouldRepositionScroll (index: number) {\n      const { data, enableSnap, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n      if (\n          !enableSnap ||\n      !dataLength ||\n      !this._enableLoop() ||\n      (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)\n      ) {\n          return false;\n      }\n      return true;\n  }\n\n  _roundNumber (num: number, decimals = 1) {\n      // https://stackoverflow.com/a/41716722/\n      const rounder = Math.pow(10, decimals);\n      return Math.round((num + Number.EPSILON) * rounder) / rounder;\n  }\n\n  _isMultiple (x: number, y: number) {\n      // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/\n      // Required because Android viewport size can return pretty complicated decimals numbers\n      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n  }\n\n  _getCustomData (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return [];\n      }\n\n      if (!this._enableLoop()) {\n          return data;\n      }\n\n      let previousItems = [];\n      let nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n          const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          const remainder = loopClonesPerSide % dataLength;\n\n          for (let i = 0; i < dataMultiplier; i++) {\n              previousItems.push(...data);\n              nextItems.push(...data);\n          }\n\n          previousItems.unshift(...data.slice(-remainder));\n          nextItems.push(...data.slice(0, remainder));\n      } else {\n          previousItems = data.slice(-loopClonesPerSide);\n          nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n  }\n\n  _getCustomDataLength (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n  }\n\n  _getCustomIndex (index: number, props: CarouselProps<TData> = this.props) {\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || typeof index === 'undefined') {\n          return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n  }\n\n  _getDataIndex (index: number) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n          return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n          return loopClonesPerSide > dataLength ?\n              (index - loopClonesPerSide) % dataLength :\n              index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n      // TODO: is there a simpler way of determining the interpolated index?\n          if (loopClonesPerSide > dataLength) {\n              const baseDataIndexes = [];\n              const dataIndexes = [];\n              const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n              const remainder = loopClonesPerSide % dataLength;\n\n              for (let i = 0; i < dataLength; i++) {\n                  baseDataIndexes.push(i);\n              }\n\n              for (let j = 0; j < dataMultiplier; j++) {\n                  dataIndexes.push(...baseDataIndexes);\n              }\n\n              dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n              return dataIndexes[index];\n          } else {\n              return index + dataLength - loopClonesPerSide;\n          }\n      } else {\n          return index - loopClonesPerSide;\n      }\n  }\n\n  // Used with `snapToItem()` and 'PaginationDot'\n  _getPositionIndex (index: number) {\n      const { loop, loopClonesPerSide } = this.props;\n      return loop ? index + loopClonesPerSide : index;\n  }\n\n  _getSnapOffsets (props: CarouselProps<TData> = this.props) {\n      const offset = this._getItemMainDimension();\n      return [...Array(this._getCustomDataLength(props))].map((_, i) => {\n          return i * offset;\n      });\n  }\n\n  _getFirstItem (index: number, props: CarouselProps<TData> = this.props) {\n      const { loopClonesPerSide } = props;\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n          return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n  }\n\n  _getWrappedRef () {\n      // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component\n      if (\n          this._carouselRef &&\n      ((this._needsScrollView() &&\n        (this._carouselRef as ScrollView).scrollTo) ||\n        (!this._needsScrollView() &&\n          (this._carouselRef as FlatList).scrollToOffset))\n      ) {\n          return this._carouselRef;\n      }\n      // https://github.com/facebook/react-native/issues/10635\n      // https://stackoverflow.com/a/48786374/8412141\n      return (\n          this._carouselRef &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode()\n      );\n  }\n\n  _getScrollEnabled () {\n      return this._scrollEnabled;\n  }\n\n  _setScrollEnabled (scrollEnabled = true) {\n      const wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n          return;\n      }\n\n      // 'setNativeProps()' is used instead of 'setState()' because the latter\n      // really takes a toll on Android behavior when momentum is disabled\n      wrappedRef.setNativeProps({ scrollEnabled });\n      this._scrollEnabled = scrollEnabled;\n  }\n\n  _getItemMainDimension () {\n      return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;\n  }\n\n  _getItemScrollOffset (index: number) {\n      return (\n          this._positions && this._positions[index] && this._positions[index].start\n      );\n  }\n\n  _getItemLayout (_: TData[], index: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      return {\n          index,\n          length: itemMainDimension,\n          offset: itemMainDimension * index // + this._getContainerInnerMargin()\n      };\n  }\n\n  // This will allow us to have a proper zIndex even with a FlatList\n  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165\n  _getCellRendererComponent ({\n      children,\n      index,\n      style,\n      ...props\n  }: PropsWithChildren<{ index: number; style: StyleProp<ViewStyle> }>) {\n      const cellStyle = [\n          style,\n          !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}\n      ];\n\n      return (\n          <View style={cellStyle} key={index} {...props}>\n              {children}\n          </View>\n      );\n  }\n\n  _getKeyExtractor (_: TData, index: number) {\n      return this._needsScrollView() ?\n          `scrollview-item-${index}` :\n          `flatlist-item-${index}`;\n  }\n\n  _getScrollOffset (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { vertical } = this.props;\n      return (\n          (event &&\n        event.nativeEvent &&\n        event.nativeEvent.contentOffset &&\n        event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) ||\n      0\n      );\n  }\n\n  _getContainerInnerMargin (opposite = false) {\n      const { activeSlideAlignment } = this.props;\n\n      if (\n          (activeSlideAlignment === 'start' && !opposite) ||\n      (activeSlideAlignment === 'end' && opposite)\n      ) {\n          return 0;\n      } else if (\n          (activeSlideAlignment === 'end' && !opposite) ||\n      (activeSlideAlignment === 'start' && opposite)\n      ) {\n          return this.props.vertical ?\n              this.props.sliderHeight - this.props.itemHeight :\n              this.props.sliderWidth - this.props.itemWidth;\n      } else {\n          return this.props.vertical ?\n              (this.props.sliderHeight - this.props.itemHeight) / 2 :\n              (this.props.sliderWidth - this.props.itemWidth) / 2;\n      }\n  }\n\n  _getActiveSlideOffset () {\n      const { activeSlideOffset } = this.props;\n      const itemMainDimension = this._getItemMainDimension();\n      const minOffset = 10;\n      // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide\n      return itemMainDimension / 2 - activeSlideOffset >= minOffset ?\n          activeSlideOffset :\n          minOffset;\n  }\n\n  _getActiveItem (offset: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      const center = offset + itemMainDimension / 2;\n      const activeSlideOffset = this._getActiveSlideOffset();\n      const lastIndex = this._positions.length - 1;\n      let itemIndex;\n\n      if (offset <= 0) {\n          return 0;\n      }\n\n      if (\n          this._positions[lastIndex] &&\n      offset >= this._positions[lastIndex].start\n      ) {\n          return lastIndex;\n      }\n\n      for (let i = 0; i < this._positions.length; i++) {\n          const { start, end } = this._positions[i];\n          if (\n              center + activeSlideOffset >= start &&\n        center - activeSlideOffset <= end\n          ) {\n              itemIndex = i;\n              break;\n          }\n      }\n\n      return itemIndex || 0;\n  }\n\n  _getSlideInterpolatedStyle (index: number, animatedValue: Animated.AnimatedInterpolation) {\n      const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n      if (slideInterpolatedStyle) {\n          return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n          return tinderAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseStackLayout()) {\n          return stackAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseShiftLayout()) {\n          return shiftAnimatedStyles(index, animatedValue, this.props);\n      } else {\n          return defaultAnimatedStyles(index, animatedValue, this.props);\n      }\n  }\n\n  _initPositionsAndInterpolators (props: CarouselProps<TData> = this.props) {\n      const { data, scrollInterpolator } = props;\n      const itemMainDimension = this._getItemMainDimension();\n\n      if (!data || !data.length) {\n          return;\n      }\n\n      const interpolators: Animated.AnimatedInterpolation[] = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach((_itemData, index) => {\n          const _index = this._getCustomIndex(index, props);\n          let animatedValue: Animated.AnimatedInterpolation;\n\n          this._positions[index] = {\n              start: index * itemMainDimension,\n              end: index * itemMainDimension + itemMainDimension\n          };\n\n          if (!this._shouldAnimateSlides(props) || !this._scrollPos) {\n              animatedValue = new Animated.Value(1);\n          } else {\n              let interpolator;\n\n              if (scrollInterpolator) {\n                  interpolator = scrollInterpolator(_index, props);\n              } else if (this._shouldUseStackLayout()) {\n                  interpolator = stackScrollInterpolator(_index, props);\n              } else if (this._shouldUseTinderLayout()) {\n                  interpolator = tinderScrollInterpolator(_index, props);\n              }\n\n              if (\n                  !interpolator ||\n          !interpolator.inputRange ||\n          !interpolator.outputRange\n              ) {\n                  interpolator = defaultScrollInterpolator(_index, props);\n              }\n\n              animatedValue = this._scrollPos.interpolate({\n                  ...interpolator,\n                  extrapolate: 'clamp'\n              });\n          }\n\n          interpolators.push(animatedValue);\n      });\n\n      this.setState({ interpolators });\n  }\n\n  _hackActiveSlideAnimation (index: number, scrollValue = 1) {\n      const offset = this._getItemScrollOffset(index);\n\n      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n          return;\n      }\n\n      const multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n      const scrollDelta = scrollValue * multiplier;\n\n      this._scrollTo({ offset: offset + scrollDelta, animated: false });\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(() => {\n          this._scrollTo({ offset, animated: false });\n      }, 1); // works randomly when set to '0'\n  }\n\n  _repositionScroll (index: number, animated = false) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n          return;\n      }\n\n      let repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n          repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n          repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, animated, false);\n  }\n\n  _scrollTo ({\n      offset,\n      index,\n      animated = true\n  }: {\n    offset: number;\n    index?: number;\n    animated: boolean;\n  }) {\n      const { vertical } = this.props;\n      const wrappedRef = this._getWrappedRef();\n      if (\n          !this._mounted ||\n      !wrappedRef ||\n      (typeof offset === 'undefined' && typeof index === 'undefined')\n      ) {\n          return;\n      }\n\n      let scrollToOffset;\n      if (typeof index !== 'undefined') {\n          scrollToOffset = this._getItemScrollOffset(index);\n      } else {\n          scrollToOffset = offset;\n      }\n\n      if (typeof scrollToOffset === 'undefined') {\n          return;\n      }\n\n      const options = this._needsScrollView() ?\n          {\n              x: vertical ? 0 : offset,\n              y: vertical ? offset : 0,\n              animated\n          } :\n          {\n              offset,\n              animated\n          };\n\n      if (this._needsScrollView()) {\n          wrappedRef.scrollTo(options);\n      } else {\n          wrappedRef.scrollToOffset(options);\n      }\n  }\n\n  _onTouchStart (event: GestureResponderEvent) {\n      const { onTouchStart } = this.props;\n\n      // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n          this.pauseAutoPlay();\n      }\n\n      onTouchStart && onTouchStart(event);\n  }\n\n  _onTouchEnd (event: GestureResponderEvent) {\n      const { onTouchEnd } = this.props;\n\n      if (\n          this._getScrollEnabled() !== false &&\n      this._autoplay &&\n      !this._autoplaying\n      ) {\n      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()\n          this.startAutoplay();\n      }\n\n      onTouchEnd && onTouchEnd(event);\n  }\n\n  _onScroll (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { onScroll, onScrollIndexChanged } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n\n      this._currentScrollOffset = scrollOffset;\n\n      if (nextActiveItem !== this._onScrollActiveItem) {\n          this._onScrollActiveItem = nextActiveItem;\n          onScrollIndexChanged &&\n        onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n      }\n\n      if (typeof onScroll === 'function' && event) {\n          onScroll(event);\n      }\n  }\n\n  _onMomentumScrollEnd (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { autoplayDelay, onMomentumScrollEnd, onSnapToItem } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n      const hasSnapped = this._isMultiple(\n          scrollOffset,\n          this.props.vertical ? this.props.itemHeight : this.props.itemWidth\n      );\n\n      // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:\n      // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated\n      // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically\n      if (nextActiveItem !== this._activeItem) {\n          this._activeItem = nextActiveItem;\n          onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n          if (hasSnapped) {\n              this._repositionScroll(nextActiveItem);\n          }\n      }\n\n      onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n      // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n      // https://github.com/facebook/react-native/issues/9439\n      if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n          clearTimeout(this._enableAutoplayTimeout);\n          this._enableAutoplayTimeout = setTimeout(() => {\n              this.startAutoplay();\n          }, autoplayDelay);\n      }\n  }\n\n  _onLayout (event: LayoutChangeEvent) {\n      const { onLayout } = this.props;\n\n      // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n      if (this._onLayoutInitDone) {\n          this._initPositionsAndInterpolators();\n          this._snapToItem(this._activeItem, false, false, true);\n      } else {\n          this._onLayoutInitDone = true;\n      }\n\n      onLayout && onLayout(event);\n  }\n\n  _snapToItem (\n      index: number,\n      animated = true,\n      fireCallback = true,\n      forceScrollTo = false\n  ) {\n      const { onSnapToItem } = this.props;\n      const itemsLength = this._getCustomDataLength();\n      const wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n          return;\n      }\n\n      if (!index || index < 0) {\n          index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n          index = itemsLength - 1;\n      }\n\n      if (index === this._activeItem && !forceScrollTo) {\n          return;\n      }\n\n      const offset = this._getItemScrollOffset(index);\n\n      if (offset === undefined) {\n          return;\n      }\n\n      this._scrollTo({ offset, animated });\n\n      // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated\n      // so we need to trigger the callback manually\n      // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically\n      // Therefore everything critical needs to be manually called here as well, even though the timing might be off\n      const requiresManualTrigger = !animated || IS_ANDROID;\n      if (requiresManualTrigger) {\n          this._activeItem = index;\n\n          if (fireCallback) {\n              onSnapToItem && onSnapToItem(this._getDataIndex(index));\n          }\n\n          // Repositioning on Android\n          if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n              if (animated) {\n                  this._androidRepositioningTimeout = setTimeout(() => {\n                      // Without scroll animation, the behavior is completely buggy...\n                      this._repositionScroll(index, true);\n                  }, 400); // Approximate scroll duration on Android\n              } else {\n                  this._repositionScroll(index);\n              }\n          }\n      }\n  }\n\n  startAutoplay () {\n      const { autoplayInterval, autoplayDelay } = this.props;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n          return;\n      }\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(() => {\n          this._autoplaying = true;\n          this._autoplayInterval = setInterval(() => {\n              if (this._autoplaying) {\n                  this.snapToNext();\n              }\n          }, autoplayInterval);\n      }, autoplayDelay);\n  }\n\n  pauseAutoPlay () {\n      this._autoplaying = false;\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearInterval(this._autoplayInterval);\n  }\n\n  stopAutoplay () {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n  }\n\n  snapToItem (index: number, animated = true, fireCallback = true) {\n      if (!index || index < 0) {\n          index = 0;\n      }\n\n      const positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n          return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n  }\n\n  snapToNext (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem + 1;\n      if (newIndex > itemsLength - 1) {\n          newIndex = 0;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  snapToPrev (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem - 1;\n      if (newIndex < 0) {\n          newIndex = itemsLength - 1;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n  triggerRenderingHack (offset = 1) {\n      this._hackActiveSlideAnimation(this._activeItem, offset);\n  }\n\n  _renderItem ({ item, index }: { item: TData; index: number }) {\n      const { interpolators } = this.state;\n      const {\n          keyExtractor,\n          slideStyle\n      } = this.props;\n      const animatedValue = interpolators && interpolators[index];\n\n      if (typeof animatedValue === 'undefined') {\n          return null;\n      }\n\n      const animate = this._shouldAnimateSlides();\n      const Component = animate ? Animated.View : View;\n      const animatedStyle = animate ?\n          this._getSlideInterpolatedStyle(index, animatedValue) :\n          {};\n      const dataIndex = this._getDataIndex(index);\n\n      const mainDimension = this.props.vertical ?\n          { height: this.props.itemHeight } :\n          { width: this.props.itemWidth };\n      const specificProps = this._needsScrollView() ?\n          {\n              key: keyExtractor ?\n                  keyExtractor(item, index) :\n                  this._getKeyExtractor(item, index)\n          } :\n          {};\n\n      return (\n          <Component\n            style={[mainDimension, slideStyle, animatedStyle]}\n            pointerEvents='box-none'\n            {...specificProps}\n          >\n              {this.props.vertical ? this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: this.props.vertical,\n                  sliderHeight: this.props.sliderHeight,\n                  itemHeight: this.props.itemHeight\n              }) : this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: !!this.props.vertical,\n                  sliderWidth: this.props.sliderWidth,\n                  itemWidth: this.props.itemWidth\n              })}\n          </Component>\n      );\n  }\n\n  _getComponentOverridableProps () {\n      const { hideCarousel } = this.state;\n      const { loopClonesPerSide } = this.props;\n      const visibleItems =\n      Math.ceil(\n          this.props.vertical ?\n              this.props.sliderHeight / this.props.itemHeight :\n              this.props.sliderWidth / this.props.itemWidth\n      ) + 1;\n      const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      const initialNumToRender = visibleItems + initialNumPerSide * 2;\n      const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;\n      const windowSize = maxToRenderPerBatch;\n\n      const specificProps = !this._needsScrollView() ?\n          {\n              initialNumToRender,\n              maxToRenderPerBatch,\n              windowSize\n          // updateCellsBatchingPeriod\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          automaticallyAdjustContentInsets: false,\n          decelerationRate: 'fast' as const,\n          directionalLockEnabled: true,\n          disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily\n          inverted: this._needsRTLAdaptations(),\n          overScrollMode: 'never' as const,\n          pinchGestureEnabled: false,\n          pointerEvents: hideCarousel ? 'none' as const : 'auto' as const,\n          // removeClippedSubviews: !this._needsScrollView(),\n          // renderToHardwareTextureAndroid: true,\n          scrollsToTop: false,\n          showsHorizontalScrollIndicator: false,\n          showsVerticalScrollIndicator: false\n      };\n  }\n\n  _getComponentStaticProps () {\n      const { hideCarousel } = this.state;\n      const {\n          activeSlideAlignment,\n          CellRendererComponent,\n          containerCustomStyle,\n          contentContainerCustomStyle,\n          firstItem,\n          getItemLayout,\n          keyExtractor,\n          style,\n          useExperimentalSnap\n      } = this.props;\n\n      const containerStyle = [\n      // { overflow: 'hidden' },\n          containerCustomStyle || style || {},\n          hideCarousel ? { opacity: 0 } : {},\n          this.props.vertical ?\n              { height: this.props.sliderHeight, flexDirection: 'column' as const } : // LTR hack; see https://github.com/facebook/react-native/issues/11960\n          // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n              {\n                  width: this.props.sliderWidth,\n                  flexDirection: this._needsRTLAdaptations() ? 'row-reverse' as const : 'row' as const\n              }\n      ];\n\n      const innerMarginStyle = this.props.vertical ?\n          {\n              paddingTop: this._getContainerInnerMargin(),\n              paddingBottom: this._getContainerInnerMargin(true)\n          } :\n          {\n              paddingLeft: this._getContainerInnerMargin(),\n              paddingRight: this._getContainerInnerMargin(true)\n          };\n\n      const contentContainerStyle = [\n          !useExperimentalSnap ? innerMarginStyle : {},\n          contentContainerCustomStyle || {}\n      ];\n\n      // WARNING: `snapToAlignment` won't work as intended because of the following:\n      // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755\n      // - Snap points will be off\n      // - Slide animations will be off\n      // - Last items won't be set as active (no `onSnapToItem` callback)\n      // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being\n      const snapProps = useExperimentalSnap ?\n          {\n          // disableIntervalMomentum: true, // Slide ± one item at a time\n              snapToAlignment: activeSlideAlignment,\n              snapToInterval: this._getItemMainDimension()\n          } :\n          {\n              snapToOffsets: this._getSnapOffsets()\n          };\n\n      // Flatlist specifics\n      const specificProps = !this._needsScrollView() ?\n          {\n              CellRendererComponent:\n            CellRendererComponent || this._getCellRendererComponent,\n              getItemLayout: getItemLayout || this._getItemLayout,\n              initialScrollIndex: this._getFirstItem(firstItem),\n              keyExtractor: keyExtractor || this._getKeyExtractor,\n              numColumns: 1,\n              renderItem: this._renderItem\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          ...snapProps,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ref: (c: any) => {\n              this._carouselRef = c as FlatList<TData> | ScrollView;\n          },\n          contentContainerStyle: contentContainerStyle,\n          data: this._getCustomData(),\n          horizontal: !this.props.vertical,\n          scrollEventThrottle: 1,\n          style: containerStyle,\n          onLayout: this._onLayout,\n          onMomentumScrollEnd: this._onMomentumScrollEnd,\n          onScroll: this._onScrollHandler,\n          onTouchStart: this._onTouchStart,\n          onTouchEnd: this._onTouchEnd\n      };\n  }\n\n  render () {\n      const { data, renderItem, useScrollView } = this.props;\n\n      if (!data || !renderItem) {\n          return null;\n      }\n\n      const props = {\n          ...this._getComponentOverridableProps(),\n          ...this.props,\n          ...this._getComponentStaticProps()\n      };\n\n      const ScrollViewComponent =\n      typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;\n\n      return this._needsScrollView() || !Animated.FlatList ? (\n          <ScrollViewComponent {...props}>\n              {this._getCustomData().map((item, index) => {\n                  return this._renderItem({ item, index });\n              })}\n          </ScrollViewComponent>\n      ) : (\n          // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between\n          // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.\n          <Animated.FlatList {...props} />\n      );\n  }\n}\n\nexport default Carousel;\n"]},"metadata":{},"sourceType":"module"}