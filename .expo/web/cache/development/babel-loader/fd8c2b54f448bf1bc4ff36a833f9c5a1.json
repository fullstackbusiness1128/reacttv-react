{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { NavigationActions, ThemeProvider, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar urlToPathAndParams = pathUtils.urlToPathAndParams;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n\n  if (isStateful(props)) {\n    return;\n  }\n\n  var navigation = props.navigation,\n      screenProps = props.screenProps,\n      persistNavigationState = props.persistNavigationState,\n      loadNavigationState = props.loadNavigationState,\n      theme = props.theme,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\", \"theme\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  var NavigationContainer = function (_React$Component) {\n    _inherits(NavigationContainer, _React$Component);\n\n    _createClass(NavigationContainer, null, [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        validateProps(nextProps);\n        return null;\n      }\n    }]);\n\n    function NavigationContainer(props) {\n      var _this;\n\n      _classCallCheck(this, NavigationContainer);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(NavigationContainer).call(this, props));\n\n      _defineProperty(_assertThisInitialized(_this), \"subs\", null);\n\n      _defineProperty(_assertThisInitialized(_this), \"_actionEventSubscribers\", new Set());\n\n      _defineProperty(_assertThisInitialized(_this), \"_handleOpenURL\", function (_ref) {\n        var url = _ref.url;\n        var _this$props = _this.props,\n            enableURLHandling = _this$props.enableURLHandling,\n            uriPrefix = _this$props.uriPrefix;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var path = parsedUrl.path,\n              params = parsedUrl.params;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            _this.dispatch(action);\n          }\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_this), \"_persistNavigationState\", function _callee(nav) {\n        var persistNavigationState;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                persistNavigationState = _this.props.persistNavigationState;\n\n                if (!persistNavigationState) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.prev = 2;\n                _context.next = 5;\n                return _regeneratorRuntime.awrap(persistNavigationState(nav));\n\n              case 5:\n                _context.next = 10;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](2);\n                console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, [[2, 7]]);\n      });\n\n      _defineProperty(_assertThisInitialized(_this), \"dispatch\", function (action) {\n        if (_this.props.navigation) {\n          return _this.props.navigation.dispatch(action);\n        }\n\n        _this._navState = _this._navState || _this.state.nav;\n        var lastNavState = _this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = function dispatchActionEvents() {\n          _this._actionEventSubscribers.forEach(function (subscriber) {\n            return subscriber({\n              type: 'action',\n              action: action,\n              state: navState,\n              lastState: lastNavState\n            });\n          });\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          _this._navState = navState;\n\n          _this.setState({\n            nav: navState\n          }, function () {\n            _this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            _this._persistNavigationState(navState);\n          });\n\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      });\n\n      _defineProperty(_assertThisInitialized(_this), \"_getScreenProps\", function () {\n        return _this.props.screenProps;\n      });\n\n      _defineProperty(_assertThisInitialized(_this), \"_getTheme\", function () {\n        if (_this.props.theme === 'light' || _this.props.theme === 'dark') {\n          return _this.props.theme;\n        } else if (_this.props.theme === 'no-preference') {\n          return 'light';\n        } else {\n          console.warn(\"Invalid theme provided: \".concat(_this.props.theme, \". Only 'light' and 'dark' are supported. Falling back to 'light'\"));\n          return 'light';\n        }\n      });\n\n      validateProps(props);\n      _this._initialAction = NavigationActions.init();\n\n      if (_this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        _this.subs = BackHandler.addEventListener('hardwareBackPress', function () {\n          if (!_this._isMounted) {\n            _this.subs && _this.subs.remove();\n          } else {\n            return _this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      _this.state = {\n        nav: _this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(_this._initialAction) : null\n      };\n      return _this;\n    }\n\n    _createClass(NavigationContainer, [{\n      key: \"_renderLoading\",\n      value: function _renderLoading() {\n        return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n      }\n    }, {\n      key: \"_isStateful\",\n      value: function _isStateful() {\n        return isStateful(this.props);\n      }\n    }, {\n      key: \"_onNavigationStateChange\",\n      value: function _onNavigationStateChange(prevNav, nav, action) {\n        if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n          if (console.group) {\n            console.group('Navigation Dispatch: ');\n            console.log('Action: ', action);\n            console.log('New State: ', nav);\n            console.log('Last State: ', prevNav);\n            console.groupEnd();\n          } else {\n            console.log('Navigation Dispatch: ', {\n              action: action,\n              newState: nav,\n              lastState: prevNav\n            });\n          }\n\n          return;\n        }\n\n        if (typeof this.props.onNavigationStateChange === 'function') {\n          this.props.onNavigationStateChange(prevNav, nav, action);\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this._navState === this.state.nav) {\n          this._navState = null;\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        var parsedUrl, userProvidedStartupState, _await$this$getStartu, action, startupState, _parsedUrl, path, params, urlAction, dispatchActions;\n\n        return _regeneratorRuntime.async(function componentDidMount$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._isMounted = true;\n\n                if (this._isStateful()) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n                  if (_statefulContainerCount > 0) {\n                    if (Platform.OS === 'ios') {\n                      console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat(docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n                    }\n                  }\n                }\n\n                _statefulContainerCount++;\n                this._linkingSub = Linking.addEventListener('url', this._handleOpenURL);\n                parsedUrl = null;\n                userProvidedStartupState = null;\n\n                if (!(this.props.enableURLHandling !== false)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                _context2.next = 11;\n                return _regeneratorRuntime.awrap(this.getStartupParams());\n\n              case 11:\n                _await$this$getStartu = _context2.sent;\n                parsedUrl = _await$this$getStartu.parsedUrl;\n                userProvidedStartupState = _await$this$getStartu.userProvidedStartupState;\n\n              case 14:\n                action = this._initialAction;\n                startupState = this.state.nav;\n\n                if (!startupState && !userProvidedStartupState) {\n                  !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n                  startupState = Component.router.getStateForAction(action);\n                }\n\n                if (userProvidedStartupState) {\n                  startupState = userProvidedStartupState;\n                  _reactNavigationIsHydratingState = true;\n                }\n\n                if (parsedUrl) {\n                  _parsedUrl = parsedUrl, path = _parsedUrl.path, params = _parsedUrl.params;\n                  urlAction = Component.router.getActionForPathAndParams(path, params);\n\n                  if (urlAction) {\n                    !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n                    action = urlAction;\n                    startupState = Component.router.getStateForAction(urlAction, startupState);\n                  }\n                }\n\n                dispatchActions = function dispatchActions() {\n                  return _this2._actionEventSubscribers.forEach(function (subscriber) {\n                    return subscriber({\n                      type: 'action',\n                      action: action,\n                      state: _this2.state.nav,\n                      lastState: null\n                    });\n                  });\n                };\n\n                if (!(startupState === this.state.nav)) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                dispatchActions();\n                return _context2.abrupt(\"return\");\n\n              case 23:\n                this.setState({\n                  nav: startupState\n                }, function () {\n                  _reactNavigationIsHydratingState = false;\n                  dispatchActions();\n                });\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, this);\n      }\n    }, {\n      key: \"getStartupParams\",\n      value: function getStartupParams() {\n        var _this$props2, uriPrefix, loadNavigationState, url, loadedNavState, _await$Promise$all, _await$Promise$all2;\n\n        return _regeneratorRuntime.async(function getStartupParams$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _this$props2 = this.props, uriPrefix = _this$props2.uriPrefix, loadNavigationState = _this$props2.loadNavigationState;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return _regeneratorRuntime.awrap(Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]));\n\n              case 4:\n                _await$Promise$all = _context3.sent;\n                _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n                url = _await$Promise$all2[0];\n                loadedNavState = _await$Promise$all2[1];\n                _context3.next = 12;\n                break;\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](1);\n\n              case 12:\n                return _context3.abrupt(\"return\", {\n                  parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n                  userProvidedStartupState: loadedNavState\n                });\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, null, this, [[1, 10]]);\n      }\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(e) {\n        if (_reactNavigationIsHydratingState) {\n          _reactNavigationIsHydratingState = false;\n          console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n          this.dispatch(NavigationActions.init());\n        } else {\n          throw e;\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        var _this$_linkingSub;\n\n        this._isMounted = false;\n\n        if ((_this$_linkingSub = this._linkingSub) === null || _this$_linkingSub === void 0 ? void 0 : _this$_linkingSub.remove) {\n          var _this$_linkingSub2;\n\n          (_this$_linkingSub2 = this._linkingSub) === null || _this$_linkingSub2 === void 0 ? void 0 : _this$_linkingSub2.remove();\n        } else {\n          Linking.removeEventListener('url', this._handleOpenURL);\n        }\n\n        this.subs && this.subs.remove();\n\n        if (this._isStateful()) {\n          _statefulContainerCount--;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var navigation = this.props.navigation;\n\n        if (this._isStateful()) {\n          var navState = this.state.nav;\n\n          if (!navState) {\n            return this._renderLoading();\n          }\n\n          if (!this._navigation || this._navigation.state !== navState) {\n            this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, function () {\n              return _this3._navigation;\n            });\n          }\n\n          navigation = this._navigation;\n        }\n\n        invariant(navigation, 'failed to get navigation');\n        return React.createElement(ThemeProvider, {\n          value: this._getTheme()\n        }, React.createElement(NavigationProvider, {\n          value: navigation\n        }, React.createElement(Component, _extends({}, this.props, {\n          navigation: navigation\n        }))));\n      }\n    }]);\n\n    return NavigationContainer;\n  }(React.Component);\n\n  _defineProperty(NavigationContainer, \"router\", Component.router);\n\n  _defineProperty(NavigationContainer, \"navigationOptions\", null);\n\n  _defineProperty(NavigationContainer, \"defaultProps\", {\n    theme: 'light'\n  });\n\n  return NavigationContainer;\n}","map":{"version":3,"mappings":"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","names":["React","NavigationActions","ThemeProvider","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","theme","containerProps","keys","Object","length","Error","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","nextProps","constructor","_defineProperty","Set","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","nav","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","_actionEventSubscribers","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_persistNavigationState","_initialAction","init","_isStateful","BackHandler","addEventListener","subs","_isMounted","remove","back","renderLoadingExperimental","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","NODE_ENV","detached","Platform","OS","_linkingSub","Linking","_handleOpenURL","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","Promise","all","getInitialURL","loadedNavState","e","_this$_linkingSub","removeEventListener","_renderLoading","_navigation","_getScreenProps","value","_getTheme"],"sources":["createAppContainer.js"],"sourcesContent":["/* eslint-disable react/sort-comp */\n\nimport * as React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport {\n  NavigationActions,\n  ThemeProvider,\n  pathUtils,\n  getNavigation,\n  NavigationProvider,\n} from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn(\n      'You passed persistenceKey prop to a navigator. ' +\n        'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' +\n        'please see the navigation state persistence docs for more information. ' +\n        'Passing the persistenceKey prop is a no-op.'\n    );\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    theme,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n  invariant(\n    (persistNavigationState === undefined &&\n      loadNavigationState === undefined) ||\n      (typeof persistNavigationState === 'function' &&\n        typeof loadNavigationState === 'function'),\n    'both persistNavigationState and loadNavigationState must either be undefined, or be functions'\n  );\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static defaultProps = {\n      theme: 'light',\n    };\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (\n        this._isStateful() &&\n        BackHandler &&\n        typeof BackHandler.addEventListener === 'function'\n      ) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.loadNavigationState\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful() &&\n        !!process.env.REACT_NAV_LOGGING\n      ) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(\n              `You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl(\n                'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n              )}`\n            );\n          }\n        }\n      }\n      _statefulContainerCount++;\n      this._linkingSub = Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState,\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      // eslint-disable-next-line react/no-access-state-in-setstate\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log(\n              'Applying Navigation Action for Initial URL:',\n              parsedUrl\n            );\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n\n      const dispatchActions = () =>\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([\n          Linking.getInitialURL(),\n          loadNavigationState && loadNavigationState(),\n        ]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState,\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...'\n        );\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async (nav) => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn(\n            'Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.'\n          );\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n\n      // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7\n      if (this._linkingSub?.remove) {\n        this._linkingSub?.remove();\n      } else {\n        Linking.removeEventListener('url', this._handleOpenURL);\n      }\n\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = (action) => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(\n        action,\n        lastNavState\n      );\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach((subscriber) =>\n          subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState,\n          })\n        );\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    _getTheme = () => {\n      if (this.props.theme === 'light' || this.props.theme === 'dark') {\n        return this.props.theme;\n      } else if (this.props.theme === 'no-preference') {\n        return 'light';\n      } else {\n        console.warn(\n          `Invalid theme provided: ${this.props.theme}. Only 'light' and 'dark' are supported. Falling back to 'light'`\n        );\n        return 'light';\n      }\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(\n            Component.router,\n            navState,\n            this.dispatch,\n            this._actionEventSubscribers,\n            this._getScreenProps,\n            () => this._navigation\n          );\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n\n      return (\n        <ThemeProvider value={this._getTheme()}>\n          <NavigationProvider value={navigation}>\n            <Component {...this.props} navigation={navigation} />\n          </NavigationProvider>\n        </ThemeProvider>\n      );\n    }\n  }\n\n  return NavigationContainer;\n}\n"]},"metadata":{},"sourceType":"module"}